## 问题520 题解

### 题目分析

这个问题要求我们找到最小的正整数 `x`，使得 `x^x` 的位数至少为 `n`。由于 `x^x` 的值会增长得非常快，直接计算 `x^x` 是不可行的，我们需要借助数学工具来处理。

### 解题思路

1.  **问题转化：使用对数**
    -   一个正整数 `Y` 的位数可以通过以10为底的对数来计算。其位数等于 `floor(log10(Y)) + 1`。
    -   根据题目要求，我们需要满足：
        `floor(log10(x^x)) + 1 >= n`
    -   这个不等式可以简化为：
        `log10(x^x) >= n - 1`
    -   利用对数的性质 `log(a^b) = b * log(a)`，我们可以进一步转化：
        `x * log10(x) >= n - 1`

2.  **单调性分析**：
    -   现在，问题变成了寻找满足 `x * log10(x) >= n - 1` 的最小正整数 `x`。
    -   我们定义函数 `f(x) = x * log10(x)`。对于 `x >= 1`，`x` 是增函数，`log10(x)` 也是增函数，因此它们的乘积 `f(x)` 也是一个严格单调递增函数。
    -   这种单调性使得我们可以高效地使用二分答案算法来寻找满足条件的 `x`。

3.  **二分答案**：
    -   我们对 `x` 的可能取值范围进行二分搜索。
    -   搜索的下界是 `1`。上界可以设定为一个足够大的数，例如 `2 * 10^9`（因为当 `x=2*10^9` 时，`x*log10(x)` 远大于 `n-1` 的最大可能值）。
    -   对于二分出的一个候选值 `mid_x`，我们去检验它的可行性。

4.  **检验函数 `check(x)`**：
    -   `check(x)` 的任务就是判断 `x * log10(x) >= n - 1` 是否成立。
    -   计算时需要使用浮点数（`double` 或 `long double`）来保证精度。

5.  **更新二分边界**：
    -   如果 `check(mid_x)` 返回 `true`，说明 `mid_x` 是一个可行的（甚至可能偏大）的解。我们想找的是**最小**的 `x`，所以我们记录下当前解 `ans = mid_x`，并尝试在 `[..., mid_x-1]` 的范围里继续搜索，即 `right = mid_x - 1`。
    -   如果 `check(mid_x)` 返回 `false`，说明 `mid_x` 太小了。我们需要一个更大的 `x`，所以在 `[mid_x+1, ...]` 的范围里搜索，即 `left = mid_x + 1`。

通过不断迭代，我们就能找到满足条件的最小整数 `x`。

**算法复杂度**：
-   总的时间复杂度是 $O(\log N_{max})$，其中 `N_max` 是搜索的上界，这是一个非常高效的算法。
