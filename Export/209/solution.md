## 问题209 题解

### 题目分析

本题是关于著名的“冰雹猜想”（也称考拉兹猜想或 3n+1 问题）的模拟。我们需要根据给定的规则生成一个数字序列，直到该数字变为1，然后将这个序列倒序输出。

规则如下：
-   若数字 $n$ 为奇数，则变为 $3n+1$。
-   若数字 $n$ 为偶数，则变为 $n/2$。

### 解题思路

这个问题可以通过两种主要方式解决：迭代（循环）或递归。由于题目要求**倒序输出**，递归的函数调用栈特性可以非常自然地实现这一要求，使得代码更为简洁。

#### 思路一：迭代模拟与反向输出

1.  **数据存储**:
    *   创建一个动态数组（例如 C++ 的 `std::vector`）来存储序列。

2.  **模拟过程**:
    *   将初始数字 $n$ 放入数组。
    *   使用一个 `while` 循环，条件为 $n \neq 1$。
    *   在循环中，根据 $n$ 的奇偶性更新 $n$ 的值，并将新值存入数组。

3.  **倒序输出**:
    *   循环结束后，我们得到了从初始 $n$ 到 $1$ 的完整正向序列。
    *   然后，我们可以反向遍历这个数组（从最后一个元素到第一个元素）并输出，或者使用 `std::reverse` 将数组整个翻转后再正序输出。

#### 思路二：递归（推荐）

递归提供了一种更优雅的解决方案，因为它能天然地实现倒序。

1.  **定义递归函数**:
    *   我们可以定义一个函数，比如 `void solve(int n)`。

2.  **递归的终止条件 (Base Case)**:
    *   当 `n == 1` 时，我们到达了序列的末尾。此时，我们直接输出 `1`，并且函数开始返回。这是倒序输出的起点。

3.  **递归的递推步骤 (Recursive Step)**:
    *   如果 `n > 1`，我们首先根据 $n$ 的奇偶性，用新值进行**递归调用**。
        *   如果 $n$ 是偶数，我们调用 `solve(n / 2)`。
        *   如果 $n$ 是奇数，我们调用 `solve(3 * n + 1)`。
    *   **关键点**：我们在**递归调用之后**，再输出当前的 `n`。
    *   这样，函数会一直深入，直到 `n=1` 时触达终止条件。然后，随着函数调用栈的逐层返回，每一层的 `n` 值才被输出。这就自然地实现了从 `1` 开始的倒序输出。

**示例 `solve(20)` 调用过程**:
```
solve(20)
  - 调用 solve(10)
    - 调用 solve(5)
      - 调用 solve(16)
        - ...
          - 调用 solve(1)
            - 打印 "1 "
          - 返回后，打印 "2 "
        - 返回后，打印 "4 "
      - ...
    - 返回后，打印 "10 "
  - 返回后，打印 "20"
```
最终输出 `1 2 4 8 16 5 10 20`。
对于本题较小的数据范围，递归方法简洁且高效。
