## 问题425 题解

### 题目分析

本题要求计算一个给定数字集合的所有子集（包括空集）中，所有元素的总和。直接暴力枚举所有 $2^n$ 个子集并求和是不可行的，因为 $n$ 最大可达30，$2^{30}$ 是一个非常巨大的数字，会导致超时。

幸运的是，题目提示中给出了解决问题的关键数学规律，我们可以利用组合数学的思想来高效地解决它。

### 解题思路：贡献法

问题的核心是**计算每个元素对总和的贡献**。

1.  **思考单个元素的出现次数**：
    -   考虑集合 $S$ 中的任意一个元素 $x$。
    -   $S$ 的任何一个子集，要么包含 $x$，要么不包含 $x$。
    -   我们要计算包含 $x$ 的子集一共有多少个。一个包含 $x$ 的子集，是由元素 $x$ 本身，加上“$S$中除$x$以外的剩下 $n-1$ 个元素所构成的集合”的任意一个子集，组合而成的。
    -   一个有 $n-1$ 个元素的集合，其子集数量为 $2^{n-1}$。
    -   因此，包含元素 $x$ 的子集数量恰好也是 $2^{n-1}$ 个。

2.  **推导公式**：
    -   既然每个元素 $x_i$ 都在所有子集中出现了 $2^{n-1}$ 次，那么它对总和的贡献就是 $x_i \times 2^{n-1}$。
    -   将所有元素的贡献加起来，就得到了最终的总和。
    -   总和 = $(x_1 + x_2 + ... + x_n) \times 2^{n-1}$
    -   **总和 = (集合S中所有元素之和) × 2^(n-1)**

### 实现步骤

基于上述公式，算法变得非常简单：

1.  **数据类型**：题目保证答案在 $10^{18}$ 范围内，因此所有用于求和与计算的变量都必须使用 `long long` 类型，以防止整数溢出。

2.  **计算元素和**：
    -   读取整数 `n`。
    -   初始化一个 `long long` 类型的变量 `sum_of_elements = 0`。
    -   循环 `n` 次，读取集合中的每一个元素，并累加到 `sum_of_elements` 中。

3.  **计算2的幂**：
    -   计算 $2^{n-1}$。对于 $n \le 30$ 的情况，最快的方法是使用位运算。
    -   表达式 `1LL << (n - 1)` 可以高效地计算出结果。`1LL` 是一个 `long long` 类型的1，它能确保整个位移操作是在64位整数上进行的，避免了 `1 << 31` 这样的潜在溢出问题。

4.  **计算总和**：
    -   将前两步的结果相乘：`total_sum = sum_of_elements * (1LL << (n - 1));`

5.  **输出**：输出 `total_sum`。

这个方法将指数级复杂度的原问题，通过数学洞察，转化为了一个线性复杂度的简单计算。
