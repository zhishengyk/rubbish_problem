## 问题467 题解

### 题目分析

本题要求我们将一个十进制数 `n` 转换为一个以负数 `-R` 为基数的数，即进行**负进制转换**。这是一个不常见的进制转换问题，其核心在于处理除法和取余操作，特别是当商或余数为负数时。

### 负进制转换的原理

常规的正进制转换（例如十进制转二进制）基于一个核心等式：$n = q \cdot b + r$，其中 $b$ 是基数，$q$ 是商，$r$ 是余数，并且余数满足 $0 \le r < b$。我们通过反复应用这个等式（“除基取余法”）来得到每一位上的数字。

对于负进制，基数 $b = -R$ 是一个负数。我们仍然希望找到一个类似的分解 $n = q \cdot (-R) + r$，但关键在于对余数 $r$ 的约束。为了让每一位上的数字是唯一的、非负的，我们必须保证余数 $r$ 满足 $0 \le r < |-R| = R$。

标准的 `%` 运算符在不同语言中对负数的处理可能不同，并且其结果可能为负，不满足我们的要求。因此，我们需要一个自定义的算法来确保余数始终为正。

### 算法步骤

我们可以通过一个循环来模拟“除基取余”的过程，直到被除数 `n` 变为0。设基数为 `base = -R`。

1.  **循环条件**: `while (n != 0)`

2.  **计算余数和商**:
    -   `remainder = n % base`
    -   `n = n / base` (这里 `n` 会被更新为下一步的被除数)

3.  **修正余数和商**:
    -   C++的 `%` 运算规则保证 `(a / b) * b + a % b == a`。如果 `n` 为负数，`remainder` 也可能为负。
    -   如果计算出的 `remainder` 是负数，我们需要进行修正，使其落入 `[0, R-1]` 的区间内。
    -   **修正规则**:
        -   如果 `remainder < 0`：
            -   `remainder = remainder + R`  (等价于 `remainder -= base`)
            -   `n = n + 1`
    -   **为什么这样修正**？
        -   原始等式是 $n_{old} = n_{new} \cdot base + remainder_{old}$。
        -   我们希望得到 $n_{old} = q' \cdot base + r'$，其中 $r' = remainder_{old} + R$。
        -   代入得 $n_{old} = q' \cdot base + (remainder_{old} + R)$。
        -   对比两个等式，可以得到 $n_{new} \cdot base = q' \cdot base + R$。
        -   $q' \cdot base = n_{new} \cdot base - R = n_{new} \cdot base + base = (n_{new} + 1) \cdot base$。
        -   所以 $q' = n_{new} + 1$。这证明了当余数加 `R` 时，商（即下一步的`n`）需要加1。

4.  **存储结果**:
    -   将每一步计算出的（修正后的）`remainder` 存入一个结果列表（如 `std::vector` 或 `std::string`）。

5.  **输出**:
    -   循环结束后，如果结果列表为空（例如输入 `n=0`），则添加一个0。
    -   将结果列表**倒序**输出。
    -   对于大于9的数字，需要转换为 `'A', 'B', ...` 等字符。

这个算法通过一个巧妙的修正步骤，将标准的整数除法调整为适用于负进制转换的形式。
