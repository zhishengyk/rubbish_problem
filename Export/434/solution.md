## 问题434 题解

### 题目分析

本题要求我们在一系列按顺序排列的景点中，通过跳过一个中间景点（非起点或终点），来找到从景点1到景点n的最短总旅行距离。距离的计算方式是曼哈顿距离，即两点坐标差的绝对值之和。

### 解题思路

这是一个优化问题。我们可以尝试所有可能的“跳过”选择，然后比较结果，找出最优解。

#### 1. 计算基准总距离

首先，我们可以计算不跳过任何景点时的总距离。路径是 `1 -> 2 -> 3 -> ... -> n`。
总距离 `TotalDist = dist(1, 2) + dist(2, 3) + ... + dist(n-1, n)`。
其中 `dist(i, j)` 是景点 `i` 和 `j` 之间的曼哈顿距离。

#### 2. 遍历并计算跳过每个景点的效果

我们被允许跳过任意一个中间景点 `i`，其中 `1 < i < n`。
当我们决定跳过景点 `i` 时，原来的路径 `... -> i-1 -> i -> i+1 -> ...` 会变成 `... -> i-1 -> i+1 -> ...`。

-   **减少的距离**：我们不再走 `i-1 -> i` 和 `i -> i+1` 这两段路。减少的距离是 `dist(i-1, i) + dist(i, i+1)`。
-   **增加的距离**：我们需要新增一条从 `i-1` 直接到 `i+1` 的路径。增加的距离是 `dist(i-1, i+1)`。

因此，跳过景点 `i` 后的新总距离可以高效地计算出来：
`NewTotalDist(i) = TotalDist - (dist(i-1, i) + dist(i, i+1)) + dist(i-1, i+1)`

#### 3. 寻找最小值

我们只需要遍历所有可以跳过的景点 `i`（从 `2` 到 `n-1`），计算出每个 `NewTotalDist(i)`，然后找出其中的最小值即可。

### 算法步骤

1.  读取所有 `n` 个景点的坐标。
2.  计算不跳过任何景点的原始总距离 `TotalDist`。
3.  初始化一个变量 `min_distance` 为一个非常大的值（或初始化为 `TotalDist`）。
4.  循环遍历 `i` 从 `2` 到 `n-1`：
    a.  计算跳过景点 `i` 后的新总距离 `current_distance`。
    b.  更新 `min_distance = min(min_distance, current_distance)`。
5.  输出 `min_distance`。

这种方法的复杂度是 O(n)，因为我们首先用 O(n) 的时间计算总距离，然后用一个 O(n) 的循环来检查每个跳过的可能。对于 $n \leq 10^5$ 的数据范围，这是非常高效和可行的。
