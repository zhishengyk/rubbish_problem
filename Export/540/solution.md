## 问题540 题解

### 题目分析

这是一个利用单调栈寻找特定性质区间的问题。我们需要找到一个连续的奶牛区间 `[A, B]`，其中 A 是最左边的奶牛，B 是最右边的奶牛，且满足：
1. A 是区间内最矮的。
2. B 是区间内最高的。
3. B 的身高严格大于 A。

### 解题思路

直接寻找同时满足最小值在左端点、最大值在右端点的区间比较复杂。我们可以简化问题：对于每个位置 `i`（作为可能的右端点 `B`），寻找其左边的一个位置 `j`（作为左端点 `A`），使得 `h[j] < h[i]`，并且 `h[j]` 是区间 `[j, i]` 的最小值。如果 `h[i]` 恰好也是这个区间的最大值，那么这个区间就满足条件。

我们可以使用一个单调栈来高效地找到这样的 `j`。

- **单调栈**：维护一个单调递减的栈，存储奶牛的**索引**。
- **算法流程**：
  1. 遍历所有奶牛，从左到右。
  2. 对于当前奶牛 `i`：
     - 将栈中所有身高**大于或等于** `h[i]` 的奶牛的索引弹出。因为对于这些弹出的奶牛 `k`，`h[i]` 不可能成为它们右侧区间的最大值（因为 `h[k] >= h[i]`）。
     - 弹栈后，如果栈不为空，那么新的栈顶元素 `j` 就是 `i` 左侧第一个身高**严格小于** `h[i]` 的奶牛。此时，我们找到了一个潜在的 `(A, B)` 对，即 `(j, i)`。
     - 在这个由 `(j,i)` 确定的区间 `[j,i]` 中，`h[j]` 是 `j` 和 `i` 之间所有元素的最小值（因为所有在 `j` 之后且在 `i` 之前的元素都因为身高大于 `h[j]` 而被保留在栈中，或者因为身高大于 `h[i]` 而被弹出，但它们都比 `h[j]` 大），而 `h[i]` 是这个区间的最大值（因为所有 `j` 和 `i` 之间的元素都比 `h[i]` 小，否则它们不会在 `j` 之后还保留在栈中）。
     - 因此，`[j, i]` 就是一个满足条件的区间。我们计算其长度 `i - j + 1` 并更新最大长度。
  3. 将当前奶牛 `i` 的索引压入栈中，以维持栈的单调性。
- **最终结果**：遍历结束后，记录下的最大长度即为答案。
