## 问题419 题解

### 题目分析

本题要求将一个（可能非常长的）二进制数转换为十六进制数。这是一个特定的进制转换任务。

对于二进制、八进制、十六进制这类基数是2的幂的进制之间的转换，存在一种比通过十进制中转更高效、更直接的方法。

### 解题思路：分组转换法

该方法利用了二进制和十六进制之间的特殊关系：**2⁴ = 16**。这意味着，**每一位十六进制数恰好可以用四位二进制数来表示**。

| 十六进制 | 二进制 |
|:---:|:---:|
| 0 | 0000 |
| 1 | 0001 |
| 2 | 0010 |
| ... | ... |
| A | 1010 |
| ... | ... |
| F | 1111 |

基于这个原理，我们可以按以下步骤进行转换：

1.  **处理输入**：将给定的二进制数以**字符串**形式读入。这一点至关重要，因为题目给出的位数`n`可能非常大（达到1e7），这远远超出了任何标准整型（如`long long`）的存储范围。

2.  **左侧补零**：转换是从右向左按4位一组进行的。为了方便处理，我们需要确保二进制字符串的长度是4的整数倍。如果不是，就在字符串的**最左边（高位）补充若干个'0'**，直到其长度成为4的倍数。
    -   例如，二进制`10110`长度为5，不是4的倍数。模4余1，需要补`4-1=3`个零，变为`00010110`。

3.  **分组映射**：
    -   建立一个从4位二进制字符串到对应十六进制字符的映射关系。这可以通过`std::map<std::string, char>`或一系列`if-else`语句实现。
    -   将补零后的二进制字符串从左到右，以4个字符为一组进行切割。
    -   对每一组4位的二进制子串，通过映射找到其对应的十六进制字符。

4.  **拼接输出**：
    -   将每组转换得到的十六进制字符按顺序拼接起来，就构成了最终的十六进制数。

这种“分组法”避免了处理可能溢出的大数，直接在字符串层面进行操作，对于处理超长数字的进制转换问题是标准且唯一的解决方案。
