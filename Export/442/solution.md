## 问题442 题解

### 题目分析

本题是经典的“猴子吃桃”问题的变种。问题描述了一个每天消耗物品的过程，并给出了最后一天（第 `n` 天）开始时的物品数量，要求我们反向推算出第一天开始时的原始数量。

-   **消耗规则**：每天吃掉当前持有数量的一半，再多吃一碗。
-   **已知条件**：在第 `n` 天准备吃的时候，发现只剩下 `1` 碗。
-   **输入/输出**：需要处理多组测试数据，每组给出一个 `n`。

### 解题思路

与标准的猴子吃桃问题一样，解决这个问题的关键在于**逆向思维**。我们可以从已知的第 `n` 天的情况出发，一步步地反推回第 `1` 天。

#### 1. 建立关系式

设 `count(d)` 为第 `d` 天早上开始时拥有的螺蛳粉碗数。
根据题意，第 `d` 天结束后，剩下的碗数，也就是第 `d+1` 天开始时的碗数 `count(d+1)`，可以表示为：
`count(d+1) = count(d) - (count(d) / 2 + 1) = count(d) / 2 - 1`

#### 2. 逆向推导公式

为了从第 `d+1` 天的情况推导出第 `d` 天的情况，我们需要将上述公式进行变换：
`count(d) / 2 = count(d+1) + 1`
`count(d) = (count(d+1) + 1) * 2`

这个公式告诉我们，前一天的数量是后一天数量加一再乘以二。

#### 3. 逐步计算

我们已知在第 `n` 天开始时，`count(n) = 1`。现在我们可以利用逆向公式，从 `d = n-1` 开始，一直计算到 `d = 1`。

-   **第 `n-1` 天的数量**：`count(n-1) = (count(n) + 1) * 2 = (1 + 1) * 2 = 4`
-   **第 `n-2` 天的数量**：`count(n-2) = (count(n-1) + 1) * 2 = (4 + 1) * 2 = 10`
-   ...依此类推。

### 算法实现

由于输入包含多组测试数据，我们需要编写一个可以循环处理输入的程序。

1.  **主循环**：在 `main` 函数中使用一个 `while (std::cin >> n)` 循环来不断读取输入的 `n` 值，直到没有更多输入为止。
2.  **计算函数**：可以创建一个独立的函数，例如 `calculate_initial(n)`，来执行具体的计算逻辑，这样使代码更清晰。
3.  **计算逻辑**：
    a.  在函数内，初始化一个变量 `bowls` 为 `1`，这代表第 `n` 天的数量。
    b.  使用一个 `for` 循环，从 `day = n - 1` 递减到 `1`。
    c.  在循环中，反复应用逆向公式：`bowls = (bowls + 1) * 2;`。
    d.  循环结束后，`bowls` 的值就是第一天的原始数量。
4.  **输出**：在主循环中，每次计算完结果后，立即输出，并换行。

考虑到 `n` 的范围是 `1 < n < 30`，最终结果可能会比较大，使用 `long long` 类型来存储碗的数量是一个好习惯，可以防止溢出。
