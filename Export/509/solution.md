## 问题509 题解

### 题目分析

这个问题要求我们将一个连续的数列分成 `M` 段，并使得各段之和中的最大值尽可能小。这是一个经典的“最大值最小化”问题，是二分答案算法的又一个典型应用。

### 解题思路

直接去寻找那个最优的划分方案来最小化最大值是非常困难的。但是，如果我们反过来问：**“能否将数列分成 `M` 段，使得每段的和都不超过 `X`？”**，这个问题就变得容易回答了。这引导我们使用二分法来搜索答案。

1.  **二分答案**：
    -   我们对“每段和的最大值”这个最终答案进行二分搜索。
    -   搜索的下界是数列中的最大单个元素值（因为每段至少包含一个元素），上界是整个数列的总和（这是只分一段的情况）。
    -   对于二分出的一个候选答案 `max_sum_limit`，我们去检验它的可行性。

2.  **检验函数 `check(max_sum_limit)`**：
    -   `check(X)` 的任务是判断：我们能否将数列分成**不超过 `M` 段**，同时保证**每一段的和都不大于 `X`**。
    -   我们可以使用贪心策略来做这个判断，计算出在满足“每段和不大于X”的条件下，**最少需要**划分成多少段：
        -   遍历数列，维护一个 `current_sum` 记录当前段的和，以及一个 `segment_count` 记录已划分的段数（初始为1）。
        -   对于一个新元素 `A[i]`，如果 `current_sum + A[i] <= X`，则可以把它加入当前段。
        -   如果 `current_sum + A[i] > X`，则当前段无法再容纳 `A[i]`。我们必须结束当前段，开启一个新段。即 `segment_count++`，并且新段的和从 `A[i]` 开始。
    -   遍历结束后，我们就得到了最少需要的段数。如果这个段数小于等于 `M`，说明 `X` 是一个可行的上限，`check(X)` 返回 `true`。否则返回 `false`。

3.  **更新二分边界**：
    -   如果 `check(X)` 返回 `true`，说明 `X` 是一个可行的（甚至可能偏大）的解。我们想找到最小的 `X`，所以我们记录下当前解 `ans = X`，并尝试在 `[..., X-1]` 的范围里继续搜索，即 `right = X - 1`。
    -   如果 `check(X)` 返回 `false`，说明 `X` 这个上限太小了，无法在 `M` 段内完成划分。我们需要一个更大的上限，所以在 `[X+1, ...]` 的范围里搜索，即 `left = X + 1`。

通过不断迭代，我们就能逼近并找到满足条件的最小的“最大段和”。

**算法复杂度**：
-   二分搜索的范围约为 `[max(A), sum(A)]`，迭代次数约为 $O(\log(\text{sum of A}))$。
-   每次 `check` 函数需要遍历 `N` 个数，时间复杂度为 $O(N)$。
-   总的时间复杂度是 $O(N \log(\text{sum of A}))$。
