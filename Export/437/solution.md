## 问题437 题解

### 题目分析

本题要求我们计算佩尔数列（Pell sequence）的第 `k` 项，并将结果对 `32767` 取模。佩尔数列的定义如下：
-   $a_1 = 1$
-   $a_2 = 2$
-   $a_n = 2 \times a_{n-1} + a_{n-2}$  (对于 $n > 2$)

输入包含多组测试数据，每组数据给出一个 `k` 值。

### 解题思路

这是一个基于给定递推关系的数列求值问题。由于 `k` 的值可能很大（最大接近一百万），直接使用递归函数来计算 `a_k` 会导致大量的重复计算和潜在的栈溢出，效率极低。

一个更高效的方法是使用**迭代**或**动态规划**的思想，从数列的初始项开始，顺次计算出后续的每一项，直到第 `k` 项。

#### 优化：预计算

由于题目包含多组测试数据，并且 `k` 的值在各个测试数据中可能不同，一个常见的优化策略是**预计算**。我们可以先找出所有测试数据中最大的 `k` 值（设为 `max_k`），然后一次性计算出佩尔数列从第1项到第 `max_k` 项的所有值，并存储起来。之后，对于每个查询，我们就可以直接从存储的结果中以 O(1) 的时间复杂度获取答案。

### 算法实现

1.  **读取输入**：
    -   首先读取测试数据的组数 `n`。
    -   然后循环 `n` 次，读取每个测试用例的 `k` 值。在读取的同时，记录下所有 `k` 值中的最大值 `max_k`。将这些 `k` 值也存储在一个数组中，以便后续输出。

2.  **预计算佩尔数列**：
    -   创建一个大小为 `max_k + 1` 的数组（例如 `pell`）来存储佩尔数列的项。
    -   **设置基本情况**：
        -   `pell[1] = 1`
        -   `pell[2] = 2`
    -   **迭代计算**：
        -   使用一个循环，从 `i = 3` 到 `max_k`，根据递推公式计算每一项：
          `pell[i] = (2 * pell[i-1] + pell[i-2]) % 32767`
        -   在每一步计算中都进行取模操作，以防止数值溢出，并确保结果正确。

3.  **输出结果**：
    -   遍历之前存储的 `k` 值数组。
    -   对于每一个 `k`，直接输出 `pell[k]` 的值。

这种方法的时间复杂度主要由预计算部分决定，为 O(`max_k`)。后续的查询非常快。这对于处理大量测试数据和较大的 `k` 值是非常高效的。
