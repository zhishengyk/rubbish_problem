## 问题522 题解

### 题目分析

本题要求我们在一个给定的正整数数组中，找到一个**和大于等于目标值 `s`** 的**长度最小的连续子数组**。

这是一个经典的数组问题。一个朴素的解法是枚举所有可能的连续子数组，计算它们的和，然后找到满足条件的最小长度。这个方法的时间复杂度为 $O(n^2)$，对于 $n$ 达到 $10^5$ 的数据规模来说，是无法接受的。我们需要一个更高效的线性时间算法。

### 解题思路：滑动窗口（双指针法）

由于数组中的所有元素都是**正整数**，这为我们使用**滑动窗口（或双指针）**技巧提供了关键的先决条件。因为窗口内的和会随着窗口的扩大而单调增加，随着窗口的缩小而单调减少。

我们可以使用两个指针，`left` 和 `right`，来定义一个动态的“窗口”，这个窗口代表一个连续子数组 `[left...right]`。算法的思路是：

1.  **扩大窗口**: 我们不断地向右移动 `right` 指针，将新的元素纳入窗口，并累加它们的和 `current_sum`。
2.  **检查与收缩窗口**: 一旦窗口内的和 `current_sum` 满足了条件（`>= s`），我们就找到了一个**可行解**。此时，我们记录下当前窗口的长度，并尝试更新全局的最小长度 `min_length`。然后，我们尝试**从左边收缩窗口**（通过向右移动 `left` 指针），并从 `current_sum` 中减去移出窗口的元素。我们持续收缩，直到窗口内的和不再满足条件。
3.  **重复**: 我们继续扩大窗口（移动 `right`），重复上述过程，直到 `right` 指针遍历完整个数组。

#### 算法步骤

1.  **初始化**:
    -   `left = 0` (窗口左边界)
    -   `current_sum = 0` (当前窗口内元素的和)
    -   `min_length = infinity` (用于存储找到的最小长度，初始值设为一个极大值)

2.  **主循环**:
    -   使用一个 `for` 循环，让 `right` 指针从 `0` 遍历到 `n-1`。
    -   在循环的每一步中，将 `nums[right]` 加入窗口：
        `current_sum += nums[right];`

3.  **内层 `while` 循环**:
    -   在将新元素加入后，使用一个 `while` 循环来检查窗口是否满足条件并尝试收缩：
        `while (current_sum >= s)`
        -   **更新最小长度**: 如果条件满足，说明我们找到了一个可行解。我们更新 `min_length`：
            `min_length = min(min_length, right - left + 1);`
        -   **收缩窗口**: 我们尝试找到一个更短的解，所以将窗口的左边界向右移动。
            `current_sum -= nums[left];`
            `left++;`
    -   这个 `while` 循环会一直执行，直到 `current_sum` 再次小于 `s`，此时我们需要继续扩大窗口来寻找下一个可行解。

4.  **处理最终结果**:
    -   外层循环结束后，`min_length` 中就保存了最小的长度。
    -   如果 `min_length` 仍然是我们初始设置的极大值，说明在整个过程中没有找到任何满足条件的子数组。在这种情况下，根据题意应返回 `0`。
    -   否则，返回 `min_length`。

这个算法的时间复杂度为 $O(n)$，因为 `left` 和 `right` 两个指针都各自只对数组进行了一次从头到尾的单向遍历。
