## 问题525 题解

### 题目分析

本题要求我们在一个数组中寻找一个“最佳”的连续子数组。这里的“最佳”有两层定义：
1.  首要条件：子数组的**算术平均数最大**。
2.  次要条件：在满足条件1的前提下，子数组的**长度最长**。

### 关键洞察与问题转化

要解决这个问题，我们首先需要确定一个数组中可能达到的最大平均值是多少。

-   设整个输入数组的最大值为 `max_val`。
-   考虑一个只包含一个 `max_val` 元素的子数组。它的长度为1，平均值就是 `max_val`。
-   现在考虑任何一个其他的子数组：
    -   如果一个子数组包含了至少一个小于 `max_val` 的元素，那么它的平均值必然**严格小于** `max_val`。
    -   如果一个子数组只包含等于 `max_val` 的元素（可能有多个），那么它的平均值**等于** `max_val`。

-   **结论**: 任何连续子数组的平均值都不可能超过 `max_val`。因此，**能达到的最大平均值就是 `max_val` 本身**。

基于这个结论，原问题的第一条要求——“算术平均数尽可能大”——就被具体化为“算术平均数等于 `max_val`”。

现在，问题被转化为：**在所有平均值为 `max_val` 的连续子数组中，找到长度最长的那个。**

一个子数组的平均值要等于 `max_val`，当且仅当这个子数组中的**所有元素都等于 `max_val`**。

所以，问题最终被简化成一个更简单的问题：**在给定的数组中，找到由数组最大值构成的最长连续子段的长度。**

### 算法步骤

1.  **找到数组的最大值**:
    -   对输入数组进行一次线性扫描，找到其中的最大元素 `max_val`。

2.  **找到最长的连续 `max_val` 子段**:
    -   再次对数组进行一次线性扫描。
    -   使用两个变量：
        -   `max_length`: 用于记录全局的最长长度，初始化为0。
        -   `current_length`: 用于记录当前连续 `max_val` 的长度，初始化为0。
    -   遍历数组中的每一个元素 `num`:
        -   如果 `num == max_val`，说明当前的连续段仍在继续，我们将 `current_length` 加一。
        -   如果 `num != max_val`，说明当前的连续段中断了。
            -   我们用 `current_length` 来更新 `max_length`：`max_length = max(max_length, current_length)`。
            -   然后将 `current_length` 重置为 0，准备开始新的计数。
    -   **收尾处理**: 当遍历结束后，需要再进行一次 `max_length = max(max_length, current_length)` 的更新。这是为了处理数组以一个 `max_val` 的连续段结尾的情况。

3.  **输出结果**:
    -   最终 `max_length` 的值就是答案。如果数组中没有 `max_val`（例如空数组，虽然本题不会出现），或者 `max_val` 只出现了一次，那么结果就是1（因为一个单独的 `max_val` 自身就是一个长度为1的子数组）。我们的算法可以自然地处理这些情况。

这个算法只需要对数组进行两次简单的线性遍历，其时间复杂度为 $O(N)$，非常高效。
