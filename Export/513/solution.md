## 问题513 题解

### 题目分析

这个问题要求我们在公路上增设最多 `K` 个路标，使得相邻路标之间的最大距离（即“空旷指数”）尽可能小。这是一个典型的“最大值最小化”问题，其标准解法是二分答案。

### 解题思路

1.  **问题转化与单调性**：
    -   直接求解最小的“最大空旷指数”很困难。但我们可以反过来思考：如果要求“最大空旷指数”不能超过 `d`，我们最少需要增设多少路标？
    -   “最大空旷指数” `d` 和“需要增设的最少路标数” `count` 之间存在单调关系：`d` 越小，`count` 就越大；`d` 越大，`count` 就越小。
    -   这种单调性是应用二分答案的基础。

2.  **二分答案**：
    -   我们对“最大空旷指数”这个最终答案进行二分搜索。
    -   搜索的下界是1，上界是公路的总长度 `L`。
    -   对于二分出的一个候选值 `d`，我们去检验它的可行性。

3.  **检验函数 `check(d)`**：
    -   `check(d)` 的任务是判断：我们能否通过增设**不超过 `K` 个**路标，使得**任意相邻路标的距离都不大于 `d`**。
    -   **具体做法**：
        -   首先，将所有原有的路标（包括起点0和终点L）的位置进行排序。
        -   然后，我们贪心地计算，要满足“最大距离不超过d”这个条件，最少需要增设多少路标。
        -   遍历所有相邻的一对原有路标，设它们之间的距离为 `dist`。
        -   如果 `dist > d`，说明这段距离太长了，必须在中间增设路标。为了使新路标间的距离也不超过 `d`，我们需要增设 `(dist - 1) / d` 个路标。
        -   我们将所有路段需要增设的路标数累加起来，得到 `total_added_signs`。
        -   如果 `total_added_signs <= K`，说明 `d` 是一个可行的上限，`check(d)` 返回 `true`。

4.  **更新二分边界**：
    -   如果 `check(d)` 返回 `true`，说明 `d` 是一个可行的（甚至可能偏大）的解。我们想找的是**最小**的 `d`，所以我们记录下当前解 `ans = d`，并尝试在 `[..., d-1]` 的范围里继续搜索，即 `right = d - 1`。
    -   如果 `check(d)` 返回 `false`，说明 `d` 这个上限太小了，`K` 个路标不够用。我们需要一个更大的上限，所以在 `[d+1, ...]` 的范围里搜索，即 `left = d + 1`。

通过不断迭代，我们就能逼近并找到满足条件的最小“最大空旷指数”。

**算法复杂度**：
-   排序原有路标：$O(N \log N)$。
-   二分搜索：迭代次数约为 $O(\log L)$。
-   每次 `check` 函数需要遍历 `N` 个路标，时间复杂度为 $O(N)$。
-   总的时间复杂度是 $O(N \log N + N \log L)$。
