## 问题206 题解

### 题目分析

本题要求我们在一个给定的日期区间内，统计所有“回文日期”的数量。一个日期被定义为回文日期，当且仅当其8位表示法（YYYYMMDD）是一个回文数，并且该日期是真实存在的。

### 解题思路

直接遍历从起始日期到终止日期的每一天，然后判断是否回文，这种方法在日期区间很大时会非常耗时。一个更高效的策略是**逆向思维**：我们不检查每个日期是否回文，而是**直接生成所有可能的回文日期**，然后判断它们是否合法且在指定区间内。

#### 构造回文日期

一个8位的回文数具有对称结构，形式为 `ABCDDCBA`。如果我们将它与日期格式 `YYYYMMDD`对应：
-   `YYYY` = `ABCD`
-   `MM` = `DC`
-   `DD` = `BA`

这揭示了一个关键规律：**一旦年份 `YYYY` 确定，其对应的回文日期的月份 `MM` 和日期 `DD` 也随之唯一确定**。
例如，如果年份是 `2011` (A=2, B=0, C=1, D=1)，那么：
-   月份 `MM` 必须是 `DC` -> `11`
-   日期 `DD` 必须是 `BA` -> `02`
-   这样就构造出了一个潜在的回文日期：`20111102`。

#### 算法步骤

1.  **解析输入**:
    *   读取起始日期 `date1` 和终止日期 `date2` 的8位整数表示。

2.  **确定年份范围**:
    *   从 `date1` 中提取起始年份 `start_year = date1 / 10000`。
    *   从 `date2` 中提取终止年份 `end_year = date2 / 10000`。

3.  **枚举年份并生成回文日期**:
    *   我们建立一个主循环，让 `year` 从 `start_year` 遍历到 `end_year`。
    *   在循环的每一步中，我们对当前的 `year` 进行以下操作：
        *   **反转年份生成月和日**: 将 `year` 的四位数字反转，得到一个四位数，这个数的前两位是日，后两位是月。
            *   例如，`year = 2011`。反转后是 `1102`。
            *   从中提取出 `month = 11` 和 `day = 02`。
        *   **合法性校验**: 检查构造出的 `(year, month, day)` 是否是一个真实存在的日期。
            *   月份 `month` 必须在 `[1, 12]` 范围内。
            *   日期 `day` 必须在 `[1, max_days_in_month]` 范围内。`max_days_in_month` 的值取决于 `month` 和 `year`（是否为闰年）。
            *   为此，需要一个辅助函数 `is_leap(year)` 来判断闰年，以及一个函数或数组来存储每个月的天数。
        *   如果日期不合法（例如，月份为0或13，或日期超过当月最大天数），则当前 `year` 无法构成一个合法的回文日期，我们继续处理下一个 `year`。
    *   **区间校验**:
        *   如果日期合法，我们将 `year`, `month`, `day` 拼接成一个8位整数 `current_date`。
        *   然后检查这个 `current_date` 是否在 `[date1, date2]` 的范围内，即 `current_date >= date1 && current_date <= date2`。
        *   如果满足条件，说明我们找到了一个符合要求的回文日期，将计数器加一。

4.  **输出结果**:
    *   遍历完所有年份后，计数器的值就是最终的答案。

这种方法的循环次数取决于年份的范围，最多约几千次，远比按天遍历要快得多，因此是一种非常高效的 **枚举** 策略。
