## 问题458 题解

### 题目分析

本题要求我们计算一个高精度整数 `a` 除以一个单精度整数 `b` 的商。这是一个典型的高精度除以低精度（大数除小数）的计算问题。由于被除数 `a` 的位数可达100位，无法用标准数据类型直接存储，因此必须采用高精度算法。

### 解题思路

解决此类问题的标准方法是模拟人类进行**长除法**的计算过程。我们从被除数的高位（最左边）开始，逐位向低位进行处理。

#### 算法步骤

1.  **数据存储**:
    -   使用 `std::string` 来存储高精度整数 `a`。
    -   使用一个标准的整型（如 `long long`）来存储单精度整数 `b`。
    -   由于长除法是从左到右计算，我们**不需要**对输入的字符串 `a` 进行反转。

2.  **模拟长除法过程**:
    -   我们需要两个辅助变量：
        -   `quotient`: 一个 `std::string`，用于在计算过程中拼接出最终的商。
        -   `remainder`: 一个 `long long` 类型的变量，用于保存每一步计算产生的余数。
    -   我们从左到右（从 `a[0]` 到 `a[n-1]`）遍历字符串 `a` 的每一位数字。
    -   在处理第 `i` 位时：
        -   **更新当前被除数**: 将上一轮的 `remainder` 乘以10，并加上当前位的数字。这模拟了在长除法中将下一位数字“拉下来”与余数组合的过程。
            `remainder = remainder * 10 + (a[i] - '0');`
        -   **计算商的当前位**: 用更新后的 `remainder` 除以 `b`，得到的结果就是商的一位数字。
            `current_digit = remainder / b;`
            我们将这个数字字符追加到 `quotient` 字符串的末尾。
        -   **更新余数**: `remainder` 对 `b` 取模，得到新的余数，用于下一轮的计算。
            `remainder = remainder % b;`

3.  **格式化输出**:
    -   **处理前导零**: 上述过程可能会在商 `quotient` 的开头产生一个或多个不必要的 '0'。例如，当 `a` 的前几位数字构成的数小于 `b` 时，商的开头就会是 '0'。我们需要在输出前移除这些前导零。
    -   可以从 `quotient` 字符串的开头向后查找第一个非 '0' 的字符，并从该位置截取到末尾作为最终结果。
    -   **处理商为零的情况**: 如果 `a < b`，计算出的 `quotient` 将完全由 '0' 组成。在去除前导零后，字符串会变空。需要特殊处理这种情况，确保最终输出一个 "0"。一个简单的实现方法是，如果去除前导零后的字符串为空，则结果就是 "0"。

这个问题与“高精度除法求商和余数”的问题几乎完全相同，只是我们最终只关心商的部分。
