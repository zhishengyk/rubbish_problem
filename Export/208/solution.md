## 问题208 题解

### 题目分析

这是一个典型的任务调度问题。我们有 $n$ 个任务（接水的游客）和 $m$ 个并行的处理器（水龙头）。每个任务有其特定的处理时间（接水量 $w_i$）。任务按照固定顺序排队，当一个处理器空闲时，队列中的下一个任务立即开始在该处理器上执行。我们的目标是计算完成所有任务所需的总时间。

### 解题思路

这个问题的最优解可以通过**贪心算法**结合**模拟**得到。总的完成时间取决于最晚结束工作的那个水龙头。为了让这个最晚的时间尽可能早，我们应该总是将新的任务（等待接水的游客）分配给**当前最早能空闲下来的水龙头**。

#### 算法步骤

1.  **数据结构**:
    *   我们可以使用一个大小为 $m$ 的数组，比如 `tap_times[m]`，来模拟这 $m$ 个水龙头。
    *   `tap_times[j]` 的值代表第 $j$ 个水龙头累计已经花费的时间。在任何时刻，这个值也表示该水龙头将在何时空闲下来，可以接受下一个任务。

2.  **初始化**:
    *   最开始，前 $m$ 位游客（编号 $1$ 到 $m$）分别占据 $m$ 个水龙头。
    *   因此，我们可以将前 $m$ 位游客的接水量 $w_1, w_2, \ldots, w_m$ 分别赋值给 `tap_times` 数组。
    *   `tap_times[j] = w_{j+1}` for $j = 0, \ldots, m-1$。

3.  **模拟后续游客的接水过程**:
    *   接下来，我们从第 $m+1$ 位游客开始，依次处理到第 $n$ 位。
    *   对于每一位新的游客 $i$（$i$ from $m+1$ to $n$）：
        *   我们需要找到当前**最早能够空闲**的水龙头。这等价于在 `tap_times` 数组中找到当前值最小的那个元素。
        *   假设 `tap_times[min_idx]` 是最小值。这意味着 `min_idx` 号水龙头是最先完成它当前任务的。
        *   那么，游客 $i$ 就会被分配到这个水龙头上。他会在 `tap_times[min_idx]` 秒时开始接水，并需要额外 $w_i$ 秒的时间。
        *   因此，这个水龙头新的完成时间将是原来的时间加上新任务的时间。我们更新 `tap_times[min_idx] = tap_times[min_idx] + w_i`。

4.  **确定最终时间**:
    *   当所有 $n$ 位游客都被分配到水龙头并计算了新的完成时间后，`tap_times` 数组中的每个元素代表了对应水龙头完成其所有被分配任务的总耗时。
    *   所有游客都接完水的总时间，取决于这 $m$ 个水龙头中**最后一个结束工作**的那个。
    *   因此，最终的答案就是 `tap_times` 数组中的**最大值**。

#### 优化
*   在第3步中，寻找 `tap_times` 中的最小值，可以通过遍历大小为 $m$ 的数组实现，时间复杂度为 $O(m)$。对于 $n-m$ 个后续游客，总复杂度为 $O((n-m) \times m)$。
*   如果使用**最小优先队列 (Min-Heap)** 来维护 $m$ 个水龙头的完成时间，每次获取最小值和插入新值的时间复杂度都是 $O(\log m)$，总复杂度可以优化到 $O((n-m) \log m)$。但对于本题的数据范围，直接遍历也足够快。

这个算法的核心思想是 **贪心调度**，确保资源（水龙头）的利用率最高，从而使总时间最小。
