## 问题480 题解

### 题目分析

这个问题要求我们从一个正整数 $n$ 中删除 $k$ 位数字，使得剩下的数字组成的整数最小。这是一个经典的贪心问题，通常使用单调栈来解决。

### 解题思路

为了使最终的整数最小，我们应该让高位的数字尽可能小。这是一个贪心策略。我们可以从左到右扫描原数的每一位，并维护一个结果序列（可以用栈实现）。

1.  **贪心选择**：当我们考虑是否要将当前数字加入结果序列时，我们观察结果序列的末尾。如果当前数字比结果序列的末尾数字小，那么保留末尾那个较大的数字在高位显然不优。因此，我们应该删除末尾的数字，用当前这个较小的数字替换它。

2.  **单调栈实现**：
    -   我们用一个栈来维护结果序列。
    -   从左到右遍历原数的每一位数字。
    -   对于当前数字 `c`，当栈不为空、栈顶元素大于 `c` 且我们还有删除名额（`k > 0`）时，就不断地弹出栈顶元素，并减少 `k`。
    -   将当前数字 `c` 压入栈中。

3.  **处理特殊情况**：
    -   如果遍历完所有数字后 `k` 仍然大于0，这说明原数（或其后缀）是单调递增的（例如 "12345"）。在这种情况下，为了使结果最小，我们应该从末尾删除 `k` 个最大的数字。
    -   处理结果的前导零。

这个算法的时间复杂度是 $O(m)$，其中 $m$ 是 $n$ 的位数，因为每个数字最多进栈和出栈一次。
