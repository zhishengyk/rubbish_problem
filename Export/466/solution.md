## 问题466 题解

### 题目分析

本题要求我们实现一种非常特殊的**变进制加法**。在这种数制中，每一位的权重和进制都与常规的数系不同。具体来说，从低位到高位，第 $i$ 位（从0开始计数）的进制是第 $i+1$ 个质数。

-   第0位（个位）：基数为2（2进制）
-   第1位（十位）：基数为3（3进制）
-   第2位（百位）：基数为5（5进制）
-   以此类推...

我们需要计算在这种奇特数制下两个数的和。

### 解题思路

这个问题的核心思想与标准的高精度加法非常相似：**从最低位开始，逐位相加，并处理进位**。唯一的区别在于，在计算每一位的进位时，我们使用的不再是固定的基数10，而是根据当前位数变化的质数基数。

#### 算法步骤

1.  **预处理质数**:
    -   我们需要一个质数列表来作为每一位的进制基数。由于输入的数字位数不会无限长（受限于字符串长度和逗号数量），我们可以预先用**埃拉托斯特尼筛法（Sieve of Eratosthenes）**或其他筛法，生成一个足够大的质数数组。例如，生成前几千个质数。

2.  **解析输入**:
    -   输入是一个形如 `"d1,d2,...,dk+e1,e2,...,em"` 的字符串。
    -   我们需要将其解析为两个独立的数字。每个数字可以存储在一个 `std::vector<int>` 中。
    -   解析时，以 `+` 号为界，分割成两个数字字符串。然后，再对每个数字字符串，以 `,` 为界，分割出每一位的数值。
    -   **重要**: 解析出的数字序列是高位在前的（例如，"1,0" -> `{1, 0}`）。为了方便计算，我们需要将这两个向量**反转**，使其变为低位在前（`{0, 1}`），这样索引0就对应个位。

3.  **变进制加法**:
    -   设反转后的两个数字向量为 `num1` 和 `num2`。
    -   创建一个空的 `result` 向量用于存储结果。
    -   初始化一个进位变量 `carry = 0`。
    -   使用一个循环，从 `i = 0` 开始，处理每一位。循环的长度由 `num1` 和 `num2` 中较长的那个决定。
    -   在第 `i` 次循环中：
        -   从预处理的质数数组中获取当前位的进制：`base = primes[i]`。
        -   获取两个数在第 `i` 位上的数字 `d1` 和 `d2`。（如果一个数比另一个短，则其高位上的数字视为0）。
        -   计算总和：`sum = d1 + d2 + carry`。
        -   **核心计算**:
            -   存入 `result` 的当前位数值是 `sum % base`。
            -   传递给下一位的新进位是 `sum / base`。
        -   将 `sum % base` 的结果存入 `result` 向量。

4.  **处理最终进位**:
    -   当主循环结束后，如果 `carry` 仍然大于0，需要将其（可能不止一位）继续按相应的质数进制分解并存入 `result` 的高位。

5.  **格式化输出**:
    -   将 `result` 向量再次**反转**，恢复为高位在前的顺序。
    -   遍历 `result` 向量，输出每一位数字。在数字之间，用逗号 `,` 分隔。

这个算法通过将标准的高精度加法进行推广，巧妙地解决了变进制的计算问题。
