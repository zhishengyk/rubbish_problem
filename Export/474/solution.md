## 问题474 题解

### 题目分析

这是一个经典的贪心算法问题，通常被称为“删除数字问题”。给定一个数字字符串和一个允许删除的数字个数 $s$，我们的目标是移除 $s$ 个数字，使得剩下的数字按原顺序组成的数最小。

### 贪心策略

为了使最终形成的数字最小，我们应遵循一个基本原则：**让数字的高位（即左边的位）尽可能小**。

基于这个原则，我们可以设计一个从左到右构建最终结果的贪心策略。当我们考虑结果的某一位时，我们总是试图选择一个尽可能小的数字。

一个非常高效且优雅的实现是利用**单调栈**的思想。我们维护一个结果字符串（或栈），并尝试使其保持一个单调不减的趋势。

#### 算法步骤

1.  **数据结构**:
    -   我们可以使用一个 `std::string` 或 `std::vector<char>` 来作为栈，存储我们构建的结果。

2.  **遍历与构建**:
    -   从左到右遍历输入的数字字符串 `n` 的每一位 `current_digit`。
    -   对于每一位 `current_digit`，我们执行以下操作：
        -   **维护单调性**: 我们查看结果栈的栈顶元素 `top_digit`。
            -   **当栈不为空、我们还有删除机会（$s > 0$）、并且栈顶元素 `top_digit` 大于 `current_digit` 时**：
                -   这意味着我们找到了一个可以被优化的“高位”。`top_digit` 是一个相对较大的数，而我们现在遇到了一个更小的数 `current_digit` 可以放在这个位置（或更早的位置）。
                -   因此，我们执行一次“删除”操作：将栈顶元素 `top_digit` 弹出。
                -   同时，将剩余删除次数 $s$ 减一。
                -   这个过程（弹出栈顶）需要在一个 `while` 循环中重复，直到上述条件不再满足。
        -   **入栈**: 将 `current_digit` 压入栈中。

3.  **处理剩余的删除次数**:
    -   当遍历完整个输入字符串 `n` 后，可能我们还没有用完所有的 $s$ 次删除机会。
    -   这种情况通常发生在输入字符串本身是单调递增的（或大部分是递增的），例如 `n="12345", s=2`。
    -   此时，为了让数字最小，我们应该从结果栈的**末尾（栈顶）**删除剩下的 $s$ 个数字，因为这些是位权最低的数字。

4.  **格式化输出**:
    -   **处理前导零**: 最终结果栈中可能包含前导零（例如，输入 `n="10048", s=1`，删除'1'后，栈中是 "0048"）。我们需要找到第一个非零字符，并从那里开始输出。
    -   **处理结果为空或全为零**: 如果最终结果为空（例如，所有数字都被删除了），或者结果只包含'0'，则应输出 "0"。

这个算法的时间复杂度为 $O(L)$，其中 $L$ 是数字字符串的长度，因为每个数字最多只入栈和出栈一次。
