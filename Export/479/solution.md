## 问题479 题解

### 题目分析

这个问题要求我们找到一个最小的整数 $M$，使得 $M > N$ 且 $M$ 和 $N$ 的二进制表示中 $1$ 的个数相同。这是一个经典的位运算问题，可以通过一系列精巧的位操作来解决。

### 解题思路

为了构造出比 $N$ 大的、1的个数相同的最小整数 $M$，我们需要对 $N$ 的二进制位进行尽可能小的改动。

1.  **找到最右边的非拖尾的'1'**：我们需要找到形如 `...011...1`（`...`代表任意二进制位）的部分，并将其中的 `01` 变为 `10`。这会使数字变大，同时保持变动位置尽可能靠右。
    -   `c1 = n & -n;` 这一步可以分离出 $N$ 最右边的'1'。
2.  **翻转这个'1'到左边的'0'**：
    -   `c2 = n + c1;` 将最右边的'1'加到 $N$ 上，这会使得这个'1'向左进位，直到遇到第一个'0'，从而实现 `...01...` 到 `...10...` 的转变。
3.  **处理右边的'1'**：经过上一步，我们得到了一个比 $N$ 大的数 `c2`，但它的'1'的个数比 $N$ 少。我们需要将右侧被“清除”的'1'重新以最小的形式（即尽可能靠右）排列。
    -   `n ^ c2` 可以得到 $N$ 和 `c2` 之间的变化位。
    -   `(n ^ c2) / c1` 将这些变化位右移。
    -   `>> 2` 将结果再右移两位，得到需要补回的'1'的个数。
    -   `c3 = (((n ^ c2) / c1) >> 2);` 得到需要补回的'1'的掩码。
4.  **合并结果**：
    -   `return c2 | c3;` 将 `c2` 和 `c3` 按位或，就得到了最终的结果。

这个算法非常高效，只需要几次位运算就可以得到答案。
