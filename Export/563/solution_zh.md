## 最小通道数调度问题解法

本题要求计算一个调度问题：给定一个入口序列，要求它们从出口以序号递减的顺序离开，最少需要多少个平行的通道（可以看作是栈）来完成这个调度。

### 核心思路

我们可以模拟这个过程。对于入口序列中的每一个数 `x`，我们需要决定将它放入哪个通道（栈）。
*   **约束条件**: 在任何一个通道（栈）中，下方的数字必须比上方的数字大。因为下方的数字要比上方的数字晚出来，而在出口处要求是递减序列，所以晚出来的数字要小。这意味着每个栈内部必须是一个递减序列。
*   **贪心策略**: 当一个新数字 `x` 到达时，我们应该将它放到哪个栈顶呢？为了给后面可能到来的、更大的数字留出空间，我们应该尽量利用现有的栈。我们应该寻找一个栈顶元素 `top`，使得 `top > x` 且 `top` 是所有满足条件的栈顶中最小的。
    *   如果找到了这样的栈，就把 `x` 压入这个栈。
    *   如果找不到（即 `x` 比所有栈顶元素都大），我们就必须新开一个栈来存放 `x`。
*   我们需要的最小通道数，就是在这个过程中我们最多同时需要开启的栈的数量。

### 关联到最长上升子序列 (LIS)

这个问题是一个经典模型，它等价于求解原序列的**最长上升子序列 (Longest Increasing Subsequence, LIS)** 的长度。

**为什么？**
这可以用 Dilworth 定理来解释。简单来说，**一个序列能被划分成的最少数量的下降子序列的个数，等于这个序列的最长上升子序列的长度**。

在我们的问题中，每个通道（栈）都必须维护一个下降子序列。我们要用最少的通道来处理整个序列，就等于要将整个序列划分为最少数量的下降子序列。因此，我们只需要求出原序列的 LIS 长度即可。

例如，对于序列 `8 4 2 5 3 9 1 6 7`：
*   一个最长上升子序列是 `2, 3, 6, 7` (或 `2, 5, 6, 7`)，长度为4。
*   所以，最少需要4个通道。
*   一种可能的划分：
    *   通道1: `8, 4, 2, 1`
    *   通道2: `5, 3`
    *   通道3: `9, 6`
    *   通道4: `7`

### LIS 的高效算法 ($O(N \log N)$)

我们可以用一个非常巧妙的贪心算法结合二分查找来在 $O(N \log N)$ 的时间内求出 LIS 的长度。

1.  维护一个辅助数组 `tails`。`tails` 数组的含义是：`tails[i]` 存储的是所有长度为 `i+1` 的上升子序列中，结尾元素最小的那一个。可以证明，`tails` 数组一定是单调递增的。
2.  遍历输入序列 `A` 中的每一个元素 `num`：
    *   **情况一**: 如果 `num` 大于 `tails` 数组中所有的元素（即 `num > tails.back()`），这意味着 `num` 可以接在目前最长的上升子序列后面，形成一个更长的子序列。我们将 `num` 直接追加到 `tails` 数组的末尾 (`tails.push_back(num)`)，LIS 的长度加一。
    *   **情况二**: 如果 `num` 不大于 `tails.back()`，我们在 `tails` 数组中通过**二分查找** (`std::lower_bound`) 找到第一个**不小于** `num` 的元素 `tails[i]`，并用 `num` 替换它。这一步的意义是：我们发现了一个可以构成长度为 `i+1` 的上升子序列的、比 `tails[i]` 更优（即更小）的结尾元素。这样，虽然 LIS 的当前长度没有增加，但我们为后续元素构成长序列创造了更有利的条件。
3.  遍历完整个输入序列 `A` 后，`tails` 数组的长度就是原序列的 LIS 的长度。

### 代码实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void solve() {
    int n;
    std::cin >> n;
    std::vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }

    if (n == 0) {
        std::cout << 0 << std::endl;
        return;
    }

    std::vector<int> tails;
    tails.push_back(a[0]);

    for (int i = 1; i < n; ++i) {
        if (a[i] > tails.back()) {
            // 情况一：扩展最长上升子序列
            tails.push_back(a[i]);
        } else {
            // 情况二：更新已有长度的子序列的最小结尾
            // 找到 tails 中第一个不小于 a[i] 的元素，并替换它
            *std::lower_bound(tails.begin(), tails.end(), a[i]) = a[i];
        }
    }

    // LIS 的长度即为所需的最少通道数
    std::cout << tails.size() << std::endl;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    solve();
    return 0;
}
```
