## 问题408 题解

### 题目分析

本题要求对n件商品的价格进行由低到高的排序。与常规排序问题不同的是，题目给出了一个关键信息：商品的价格在0到1000之间。这个有限且较小的整数范围是解决问题的关键。

### 解题思路

虽然使用通用的排序算法（如`std::sort`）可以解决问题，但考虑到价格范围的特性，**计数排序（或称为桶排序）** 是一个更高效的选择。

1.  **算法选择**：
    - **计数排序**：这是一种非比较排序算法，它的时间复杂度为O(N + K)，其中N是待排序元素的数量，K是元素的范围（在本题中K=1001）。当K相对于N较小时，计数排序的效率非常高。
    - **`std::sort`**：这是一种基于比较的排序算法，时间复杂度通常为O(N log N)。

    对于本题`N`最大为100000，而`K`只有1001，O(N + K) 明显优于 O(N log N)。因此，我们选择计数排序。

2.  **实现步骤**：
    - **创建桶**：声明一个大小为1001的整型数组（或向量）`counts`，用于记录每个价格出现的次数。`counts[i]`将存储价格`i`的商品数量。将所有元素初始化为0。
    - **计数**：循环读取n个商品的价格。每读取一个价格`p`，就将`counts[p]`的值加1。这个过程就像把每个商品放入对应价格的“桶”里。
    - **输出**：遍历`counts`数组，从索引0到1000。对于每个索引`price`，根据其计数值`counts[price]`，循环输出`price`值`counts[price]`次。这样，所有价格就自然地按从小到大的顺序被输出了。

这个方法充分利用了题目给出的数据范围特性，实现了线性的时间复杂度，是解决此类问题的最优解法。
