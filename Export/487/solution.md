## 问题487 题解

### 题目分析

这个问题涉及到对一个数列进行多次区间更新（给一个区间内的所有数加上一个值），然后查询最终数列的最小值。如果对每次操作都遍历区间进行更新，当操作次数和区间长度很大时，效率会很低。这是一个适合使用差分数组解决的典型问题。

### 解题思路

差分数组是前缀和的逆运算，它可以将区间操作转化为单点操作，从而大大提高效率。

1.  **构造差分数组**：
    -   首先，我们根据初始积分数组 `a` 构造一个差分数组 `diff`。
    -   `diff[i] = a[i] - a[i-1]` (对于 `i > 1`)
    -   `diff[1] = a[1]`
    -   这样，原数组 `a` 就是 `diff` 数组的前缀和。

2.  **处理区间更新**：
    -   当我们要给区间 `[x, y]` 的所有参与者增加 `z` 分时，这相当于让 `a[x], a[x+1], ..., a[y]` 都增加了 `z`。
    -   反映到差分数组上，这只会影响到 `diff[x]` 和 `diff[y+1]`：
        -   `a[x]` 增加了 `z`，而 `a[x-1]` 不变，所以 `diff[x] = a[x] - a[x-1]` 增加了 `z`。
        -   `a[y]` 增加了 `z`，而 `a[y+1]` 不变，所以 `diff[y+1] = a[y+1] - a[y]` 减少了 `z`。
    -   因此，一个区间更新操作 `(x, y, z)` 就变成了两个单点操作：`diff[x] += z` 和 `diff[y+1] -= z`。

3.  **还原最终数组并求最小值**：
    -   在处理完所有 `p` 次更新后，我们得到了最终的差分数组。
    -   我们可以通过对差分数组求前缀和来还原出最终的积分数组 `a`。
    -   `a[i] = a[i-1] + diff[i]`
    -   在还原的过程中，我们可以同时遍历并找到最小值。

这个算法的总时间复杂度是 $O(n+p)$，其中 $O(n)$ 用于构造初始差分数组和最终求最小值， $O(p)$ 用于处理所有更新操作。
