## 问题528 题解

### 题目分析

本题要求我们在一个给定的整数数组中，找到**最长的连续算术子数组**的长度。一个算术数组（或等差数列）的定义是，其相邻元素之间的差值是恒定的。

### 解题思路

这是一个可以通过单次线性扫描解决的问题。我们的核心思想是从左到右遍历数组，同时维护当前正在形成的连续算术子数组的状态（长度和公差）。当这个子数组的算术性质被破坏时，我们就记录下它的长度，并开始一个新的算术子数组的计数。

#### 算法步骤

1.  **处理边界情况**:
    -   如果数组的长度 $N \le 2$，那么整个数组本身就是一个算术子数组（因为任何只有一个或两个元素的序列都是算术序列）。因此，可以直接输出 $N$。

2.  **初始化**:
    -   `max_length`: 用于存储全局的最长长度。由于 $N > 2$，最长的算术子数组至少为2，所以可以初始化为 `2`。
    -   `current_length`: 用于记录当前正在考察的算术子数组的长度。我们从前两个元素开始，所以初始化为 `2`。
    -   `diff`: 记录当前算术子数组的公差。初始化为 `A[1] - A[0]`。

3.  **线性扫描**:
    -   我们从数组的第三个元素（索引为2）开始，向右遍历直到数组末尾（`i` from 2 to $N-1$）。
    -   在循环的每一步中，我们比较新元素与前一个元素的差值和我们当前维护的公差 `diff`：
        -   **情况 A: 算术性质得以延续**
            -   如果 `A[i] - A[i-1] == diff`：
                -   这说明 `A[i]` 可以加入到当前的算术子数组中。
                -   我们增加当前长度：`current_length++`。
        -   **情况 B: 算术性质被破坏**
            -   如果 `A[i] - A[i-1] != diff`：
                -   这意味着从 `A[i-1]` 和 `A[i]` 开始，一个**新**的算术序列诞生了。
                -   首先，我们需要用刚刚结束的那个旧序列的长度 `current_length` 来尝试更新全局的 `max_length`：
                    `max_length = max(max_length, current_length);`
                -   然后，我们**重置**当前状态，以开始记录这个新序列：
                    -   新的算术序列由 `A[i-1]` 和 `A[i]` 两个元素构成，所以 `current_length = 2`。
                    -   新的公差是 `diff = A[i] - A[i-1]`。

4.  **收尾处理**:
    -   当循环结束后，`current_length` 中还保存着**最后一个**算术子数组的长度。这个长度还没有机会与 `max_length` 进行比较。
    -   因此，在循环外，我们需要做最后一次更新：
        `max_length = max(max_length, current_length);`

5.  **处理多组输入**:
    -   将上述逻辑封装成一个函数。
    -   根据题目要求，读取测试数据组数 $T$，并循环调用解决函数。
    -   注意按照 `Case #x: y` 的格式进行输出。

这个算法的时间复杂度为 $O(N)$，因为它只需要对数组进行一次完整的遍历。空间复杂度为 $O(1)$（如果不考虑输入数组本身）。
