## 问题457 题解

### 题目分析

本题要求我们计算一个大整数 $N$ 除以一个普通整数 $d$（在本题中 $d=13$）的商和余数。由于被除数 $N$ 的长度可达100位，超过了标准数据类型的范围，这是一个典型的高精度除以低精度（大数除小数）的问题。

### 解题思路

解决这个问题的标准方法是模拟我们手算时使用的**长除法**。长除法的特点是从被除数的高位（左侧）开始，逐位向低位（右侧）进行计算。

#### 算法步骤

1.  **数据存储**:
    -   使用 `std::string` 来存储大整数 $N$。
    -   与加减乘法不同，长除法是从左到右进行的，所以我们**不需要**反转输入的字符串。

2.  **模拟长除法过程**:
    -   我们需要两个变量来辅助计算：
        -   一个 `long long` 类型的变量 `remainder`（或 `current_dividend`），用于存储在计算过程中累积的、当前正要被除的数。初始值为 0。
        -   一个 `std::string` 类型的变量 `quotient`，用于拼接出最终的商。
    -   我们从左到右遍历大数 $N$ 的每一位字符 `N[i]`：
        -   **将被除数“扩大”**: 将上一轮的余数乘以10，并加上当前位的数字，形成一个新的当前被除数。
            `remainder = remainder * 10 + (N[i] - '0');`
            这个过程等价于在手算除法时，将下一位数字“拉下来”附在余数的后面。
        -   **计算当前位的商**: 用这个新的 `remainder` 除以 $d$ (13)，得到的结果就是商的当前位数字。
            `quotient.push_back(remainder / 13 + '0');`
        -   **更新余数**: `remainder` 对 $d$ (13) 取模，得到的结果将作为下一轮计算的基础。
            `remainder = remainder % 13;`

3.  **格式化输出**:
    -   **处理商的前导零**:
        -   上述过程可能会在 `quotient` 字符串的开头产生一个或多个 '0'（例如，当 $N$ 的前几位构成的数小于13时）。
        -   我们需要找到 `quotient` 字符串中第一个非 '0' 的字符的位置，并从该位置开始输出。
        -   一个特殊情况是，如果商本身就是0（例如 `12 / 13`），结果 `quotient` 会是 "0"。此时我们应该输出 "0"，而不是空字符串。因此，如果整个商字符串都是 '0'，则保留一个。
    -   **输出余数**:
        -   当遍历完 $N$ 的所有位后，`remainder` 变量中剩下的值就是最终的余数。直接输出即可。

通过这种方式，我们将一个复杂的大数除法问题，分解为一系列简单的整数除法和取模运算，从而得到正确的结果。
