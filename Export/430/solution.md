## 问题430 题解

### 题目分析

本题的核心是根据一个特定规则筛选整数。这个规则被称为“半个回文数”，其定义需要我们同时处理三种不同进制下的数：

一个整数`N`是“半个回文数”，当且仅当它同时满足以下两个条件：
1.  `N`本身（在十进制下）**不是**一个回文数。
2.  `N`的二进制表示**是**回文数，**或者** `N`的十六进制表示**是**回文数。

我们需要从一批输入的整数中，找出所有符合这个定义的数。

### 解题思路

解决这个问题的最直接方法就是**模拟**题目的判断流程。对每一个输入的数，我们依次进行检查。

#### 算法框架

对于输入的每一个整数`num`：
1.  **检查十进制**：
    -   首先判断`num`在十进制下是否是回文数。
    -   如果是，那么它直接不满足条件1，我们就可以跳过这个`num`，继续处理下一个输入的数。

2.  **检查二进制和十六进制**：
    -   只有当`num`**不是**十进制回文数时，我们才需要进行这一步的检查。
    -   判断`num`的二进制表示是否是回文数。
    -   判断`num`的十六进制表示是否是回文数。
    -   只要这两个判断中**至少有一个**为真（使用逻辑或`||`连接），那么`num`就满足条件2。
    -   此时，我们就将`num`输出。

#### 核心辅助函数

为了实现上述框架，我们需要编写一些可复用的辅助函数：

1.  **进制转换函数 `to_base_string(long long n, int base)`**:
    -   这个函数是核心，它能将一个`long long`类型的十进制数`n`转换成`base`进制的字符串。
    -   实现方法是“除基取余，逆序排列”。
    -   对于十六进制，需要额外处理10-15到'A'-'F'的字符映射。

2.  **回文判断函数 `is_palindrome(const std::string& s)`**:
    -   这个函数用于判断一个字符串是否是回文。
    -   最简洁的方法是比较字符串`s`和它自身的反转版本是否相等。

#### C++ 实现细节
-   **十进制转字符串**：可以直接使用C++11标准库中的`std::to_string()`函数。
-   **二进制/十六进制转字符串**：需要自己实现`to_base_string`函数。
-   **主逻辑**：一个`for`循环遍历所有输入，内部嵌套`if/else if`结构来实现上述的判断流程。

通过这种方式，我们可以清晰地将问题分解为“进制转换”和“回文判断”两个子问题，然后组合起来完成最终的筛选任务。
