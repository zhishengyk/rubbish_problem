## 问题514 题解

### 题目分析

这个问题要求我们在给定的 `N` 个隔间中，选择 `C` 个来安置牛，目标是使得这 `C` 头牛中，任意相邻两头牛之间的“最近距离”最大化。

这是一个经典的“最大化最小值”问题，其标准解法是二分答案。

### 解题思路

1.  **问题转化与单调性**：
    -   直接去寻找那个最优的安置方案来最大化“最近距离”是非常困难的。
    -   但我们可以反过来思考：如果要求“最近距离”**不小于** `d`，我们最多可以安置多少头牛？
    -   “最近距离” `d` 和“能安置的最多牛数” `count` 之间存在单调关系：`d` 越大，能满足条件的隔间就越少，`count` 就越小。反之，`d` 越小，`count` 就越大。
    -   这种单调性是应用二分答案的基础。

2.  **二分答案**：
    -   我们对“最近距离”这个最终答案进行二分搜索。
    -   搜索的下界是1，上界是 `(最后一个隔间的坐标 - 第一个隔间的坐标)`。
    -   对于二分出的一个候选值 `d`，我们去检验它的可行性。

3.  **检验函数 `check(d)`**：
    -   `check(d)` 的任务是判断：我们能否安置**至少 `C` 头**牛，使得它们之间的**距离都不小于 `d`**。
    -   **具体做法（贪心策略）**：
        -   首先，对所有隔间的坐标进行升序排序。
        -   为了尽可能多地放下牛，我们应该总是把牛放在满足条件的最左边的隔间。
        -   所以，我们总是在第一个隔间（坐标最小的）放下第一头牛。
        -   然后，我们向右遍历所有隔间，寻找下一个可以放牛的位置。如果当前隔间的坐标与上一头牛的坐标之差大于或等于 `d`，我们就在这里放下下一头牛，并更新“上一头牛的位置”。
        -   遍历结束后，我们统计总共放下了多少头牛。如果这个数量大于等于 `C`，说明距离 `d` 是可行的，`check(d)` 返回 `true`。

4.  **更新二分边界**：
    -   如果 `check(d)` 返回 `true`，说明 `d` 是一个可行的（甚至可能偏小）的解。我们想找的是**最大**的 `d`，所以我们记录下当前解 `ans = d`，并尝试在 `[d+1, ...]` 的范围里继续搜索，即 `left = d + 1`。
    -   如果 `check(d)` 返回 `false`，说明 `d` 这个距离太大了，无法放下 `C` 头牛。我们需要一个更小的距离，所以在 `[..., d-1]` 的范围里搜索，即 `right = d - 1`。

通过不断迭代，我们就能逼近并找到满足条件的最大的“最近距离”。

**算法复杂度**：
-   排序隔间坐标：$O(N \log N)$。
-   二分搜索：迭代次数约为 $O(\log(\text{max\_coord}))$。
-   每次 `check` 函数需要遍历 `N` 个隔间，时间复杂度为 $O(N)$。
-   总的时间复杂度是 $O(N \log N + N \log(\text{max\_coord}))$，但由于 `log N` 通常比 `log(max_coord)` 小，所以可以近似看作 $O(N \log(\text{max\_coord}))$ 或在分析时写作 $O(N \log N)$。
