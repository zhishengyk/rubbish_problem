## 问题470 题解

### 题目分析

这是一个经典的**活动选择问题**（Activity Selection Problem），也被称为**区间调度问题**。我们有一系列的活动，每个活动都有一个起始时间和结束时间。我们的目标是在所有活动中挑选出一个子集，使得子集中的活动数量最多，且这些活动在时间上互不冲突。

这个问题是**贪心算法**的典型应用场景。

### 贪心策略的选择与证明

对于区间调度问题，有几种看似可行的贪心策略，但只有一种是保证最优的。

1.  **按开始时间最早排序？** -> 错误。反例：选择了一个开始时间很早但持续时间非常长的活动（如 `[0, 100]`），这可能会导致我们错过许多在 `[1,2]`, `[3,4]`, ... 等时间段内的短活动。

2.  **按活动持续时间最短排序？** -> 错误。反例：假设有三个活动 `[0,6]`, `[7,12]`, `[5,8]`。持续时间最短的是 `[5,8]`。如果我们选择了它，就无法再选择 `[0,6]` 和 `[7,12]`，总共只能选1个。但最优解是选择 `[0,6]` 和 `[7,12]`，共2个。

3.  **按结束时间最早排序？** -> **正确**。这是解决该问题的标准贪心策略。

**为什么按结束时间最早排序是最优的？**
直观地想，选择一个结束时间最早的活动，可以为后续的活动留下尽可能多的可用时间窗口。这使得我们有更多的机会来安排更多的活动。
一个更严谨的证明思路（“交换论证”）是：假设存在一个不包含“第一个结束的活动”的最优解，我们可以证明，总能用“第一个结束的活动”替换掉这个最优解中的某个活动，而解的数量不会变差，从而说明我们的贪心选择至少和最优解一样好。

### 算法步骤

1.  **数据结构**:
    -   定义一个结构体 `Activity`，包含 `start_time` 和 `end_time` 两个成员。
    -   创建一个 `Activity` 类型的 `std::vector` 来存储所有 $n$ 个活动。

2.  **数据读取**:
    -   读取活动总数 $n$。
    -   循环 $n$ 次，读取每个活动的起始和结束时间，并存入向量中。

3.  **排序**:
    -   这是算法的核心步骤。我们对存储所有活动的向量进行排序。
    -   排序的**主键是 `end_time`**，按**升序**排列。
    -   如果 `end_time` 相同，可以按 `start_time` 升序作为次要排序键，但这对于正确性不是必需的。

4.  **贪心选择**:
    -   初始化已选活动数量 `count = 0`。
    -   初始化一个变量 `last_activity_end_time = -1` (或一个比所有可能开始时间都小的值)，用来记录最后一个被选入方案的活动的结束时间。
    -   遍历**排序后**的活动列表：
        -   对于当前活动 `current_activity`，检查它是否与我们方案中最后一个活动冲突。
        -   不冲突的条件是：`current_activity.start_time >= last_activity_end_time`。
        -   如果满足这个条件，说明我们可以选择这个活动。
            -   `count` 加 1。
            -   更新 `last_activity_end_time` 为 `current_activity.end_time`。
        -   如果不满足，则跳过这个活动，因为它与已选的方案冲突。

5.  **输出结果**:
    -   遍历完成后，`count` 的值就是最多能安排的活动数量。

这个算法的时间复杂度主要由排序决定，为 $O(N \log N)$。
