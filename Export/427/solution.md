## 问题427 题解

### 题目分析

本题是一个经典的算法问题：在一个整数数组中，只有一个数字出现了奇数次，其他所有数字都出现了偶数次。题目要求我们用线性时间复杂度 $O(n)$ 和常数空间复杂度 $O(1)$ 来找出这个特殊的数字。

这两个限制条件非常严格，它排除了许多常规方法：
-   **哈希表/Map计数法**：虽然时间复杂度是 $O(n)$，但空间复杂度也是 $O(n)$，不满足常数空间的要求。
-   **排序法**：先对数组排序，然后遍历查找。排序的时间复杂度至少是 $O(n \log n)$，不满足线性时间的要求。

因此，我们需要一种更巧妙的方法，而这个方法就是**位运算**中的**按位异或（XOR）**。

### 解题思路：按位异或（XOR）

XOR 运算有几个非常关键的性质，是解决本题的基础：

1.  **归零律**：任何数与它自身进行异或，结果为 0。 `a ^ a = 0`
2.  **恒等律**：任何数与 0 进行异或，结果为它本身。`a ^ 0 = a`
3.  **交换律**：`a ^ b = b ^ a`
4.  **结合律**：`(a ^ b) ^ c = a ^ (b ^ c)`

利用这些性质，我们可以得出一个推论：**一串数字进行异或运算，结果与它们的顺序无关，并且任何成对出现的数字都会相互抵消，最终结果为0。**

例如：`a ^ b ^ c ^ a ^ c = (a^a) ^ (c^c) ^ b = 0 ^ 0 ^ b = b`

#### 算法实现

现在，我们将这个原理应用到题目中：
-   我们有一堆数字，其中除了一个“孤单”的数之外，其他数都是成双成对（偶数次）出现的。
-   如果我们把所有这些数字全部异或在一起：
    -   所有出现了偶数次的数字，会两两配对，异或后自我抵消，贡献为0。
    -   最终，只剩下那个出现了奇数次的数字，它找不到可以配对的数来抵消自己。
    -   这个“孤单”的数与一堆0异或，根据恒等律，最终结果就是它本身。

#### C++ 代码逻辑
1.  初始化一个变量 `result = 0`。
2.  遍历所有输入的数字 `num`。
3.  在循环中，执行累积异或操作 `result ^= num;`。
4.  循环结束后，`result` 变量的值就是那个唯一出现了奇数次的数。

这个算法只对数组进行了一次遍历，时间复杂度为 $O(n)$；只使用了一个额外的变量来存储结果，空间复杂度为 $O(1)$，完美地满足了题目的所有要求。
