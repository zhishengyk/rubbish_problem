## 问题488 题解

### 题目分析

这个问题要求我们计算一个 $n \times n$ 网格上每个点被多少个矩形覆盖。这是一个经典的二维差分问题。如果对每个矩形都遍历其覆盖的所有点进行累加，当矩形数量和大小都很大时，效率会非常低。

### 解题思路

我们可以利用二维差分数组将矩形区域的更新操作转化为对四个角的单点操作，从而大大提高效率。

1.  **二维差分数组**：我们定义一个二维差分数组 `diff`。`diff[i][j]` 记录了 `(i,j)` 点相对于其邻近点（左方、上方、左上方）的变化量。

2.  **矩形更新操作**：当我们要为一个左上角为 `(x1, y1)`，右下角为 `(x2, y2)` 的矩形区域内的所有点的值都加1时，我们可以通过在差分数组的四个关键位置进行修改来实现：
    -   `diff[x1][y1] += 1`：使得从 `(x1, y1)` 开始的所有点（右下方）的值都+1。
    -   `diff[x1][y2+1] -= 1`：抵消掉从 `(x1, y2+1)` 开始的区域被多加的1。
    -   `diff[x2+1][y1] -= 1`：抵消掉从 `(x2+1, y1)` 开始的区域被多加的1。
    -   `diff[x2+1][y2+1] += 1`：补偿回 `(x2+1, y2+1)` 右下方的区域被多减的1。
    这样，一个矩形更新操作就变成了四个单点操作，时间复杂度为 $O(1)$。

3.  **还原结果矩阵**：在处理完所有 `m` 个矩形更新后，我们需要从差分数组 `diff` 还原出最终的覆盖次数矩阵 `result`。这可以通过计算二维前缀和来实现：
    -   `result[i][j] = result[i-1][j] + result[i][j-1] - result[i-1][j-1] + diff[i][j]`
    这个还原过程的时间复杂度是 $O(n^2)$。

总的算法复杂度为 $O(m + n^2)$，对于本题的数据范围非常高效。
