## 问题464 题解

### 题目分析

本题要求我们实现一个能够处理B进制（$2 \le B \le 36$）大数加法的计算器。由于输入的数字长度可达2000位，远远超过了标准数据类型的范围，这是一个典型的**多进制高精度加法**问题。

### 解题思路

解决这个问题的核心是实现一个通用的N进制高精度加法函数。这个过程需要模拟我们手算时所用的竖式加法，但要把其中的运算规则从十进制推广到任意进制 `B`。

#### 1. 字符与数值的转换

由于 $B$ 进制的数位表示可能包含字母（当 $B>10$ 时），我们需要一套机制来在字符表示和数值之间进行转换。
-   **字符 -> 数值 (`to_digit`)**: 需要一个函数，它能将字符 `'0'-'9'` 转换为数值 `0-9`，并将字符 `'A'-'Z'` 转换为数值 `10-35`。
-   **数值 -> 字符 (`to_char`)**: 同样需要一个函数，完成相反的转换，将数值 `0-35` 映射回对应的字符表示。

#### 2. B进制高精度加法函数

这是算法的核心。我们可以设计一个函数 `string add(string num1, string num2, int base)` 来完成这个任务。

1.  **预处理**:
    -   为了方便从最低位（个位）开始计算，我们将输入的两个数字字符串 `num1` 和 `num2` **反转**。

2.  **模拟竖式加法**:
    -   初始化一个空字符串 `result` 用于存储结果，并设置一个进位变量 `carry = 0`。
    -   使用一个循环，从最低位（索引0）开始，逐位对齐相加。循环的长度取决于两个数中较长的那个。
    -   在处理第 `i` 位时：
        -   使用 `to_digit` 函数获取 `num1[i]` 和 `num2[i]` 对应的数值 `d1` 和 `d2`。（如果某个字符串已经遍历完，则其对应数值视为0）。
        -   计算当前位的总和：`sum = d1 + d2 + carry`。
        -   **关键步骤**:
            -   结果的当前位数值是 `sum % base`。
            -   传递给下一位的新进位是 `sum / base`。
        -   使用 `to_char` 函数将 `sum % base` 的结果转换回字符，并追加到 `result` 字符串的末尾。

3.  **处理最终进位**:
    -   当循环结束后，如果 `carry` 仍然大于0，需要将其转换为字符并追加到 `result` 的末尾。

4.  **格式化输出**:
    -   将最终的 `result` 字符串再次**反转**，以恢复为正常的从高位到低位的顺序。
    -   处理特殊情况，如输入为"0"等。

#### 3. 主程序逻辑

1.  读取进制 `B`。
2.  读取两个B进制的数字字符串 `s1` 和 `s2`。
3.  调用 `add(s1, s2, B)` 函数得到结果。
4.  输出结果。

这个算法将复杂的进制运算问题，通过模拟和分解，转化为了基础的整数算术运算。
