## 问题416 题解

### 题目分析

本题要求计算一个给定的非负整数`N`在其二进制表示中包含的`1`的个数。这是一个纯粹的位运算问题，也常被称为“汉明权重”（Hamming Weight）问题。

### 解题思路

有多种方法可以解决此问题，其中一个非常巧妙和高效的方法是利用 `n & (n - 1)` 这个位运算技巧。

#### 方法：巧用 `n & (n - 1)`

1.  **核心原理**：
    -   对于任何一个大于0的整数`n`，执行按位与操作 `n & (n - 1)` 的结果，会把`n`的二进制表示中**最低位的那个`1`变成`0`**，而其他位保持不变。
    -   例如，如果 `n = 100`，其二进制是 `01100100`。
    -   `n - 1` 是 `99`，其二进制是 `01100011`。
    -   `n & (n - 1)` 的结果是 `01100000`（即96），可以看到，原来`n`中最低位的`1`（在第三位）被消除了。
    -   再对`96`做同样操作 `96 & 95`，会消除下一个最低位的`1`，直到`n`变为0。

2.  **实现步骤**：
    -   初始化一个计数器`count`为0。
    -   设置一个循环，条件是`n > 0`。
    -   在循环体内，执行两个操作：
        1.  将`n`更新为其与`n - 1`的按位与结果：`n = n & (n - 1);`。
        2.  计数器`count`加1。
    -   每次循环都消除一个`1`，因此，当`n`最终变为0时，循环结束，`count`的值就是原数中`1`的总个数。

3.  **优势**：
    -   这个算法的循环次数恰好等于二进制中`1`的个数，而不是数字的总位数。对于稀疏的`1`（即大部分位是0），这种方法比逐位检查要快得多。

#### 其他方法简介

-   **逐位检查**：循环中用`n & 1`判断最低位，然后`n >>= 1`右移。简单直观，但循环次数等于数的位数。
-   **内置函数**：在GCC/Clang编译器中，可以直接使用`__builtin_popcount(n)`，它利用硬件指令实现，是速度最快的方法，但在某些非标准环境或竞赛平台可能不支持。

对于算法学习和大多数应用场景，`n & (n - 1)` 技巧是既高效又具有普遍性的最佳选择。
