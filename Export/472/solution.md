## 问题472 题解

### 题目分析

本题是一个经典的**区间选点问题**。给定一系列闭区间，我们需要找到一个最小的点集，使得每个区间都至少包含该点集中的一个点。这个问题是**贪心算法**的另一个经典应用场景。

### 贪心策略的选择

我们的目标是用最少的点“覆盖”所有的区间。一个自然的想法是，我们选择的每一个点都应该尽可能地高效，即能一次性覆盖尽可能多的区间。

考虑以下几种贪心策略：
-   **按区间的左端点升序排序？** 这不是一个好策略。如果我们优先处理一个左端点很早但区间很长的区间（如 `[0, 100]`），我们可能会在 `0` 处放一个点。但这个点可能对其他许多区间（如 `[90, 95]`, `[98, 99]`）毫无帮助。
-   **按区间的长度升序排序？** 这也不是最优的。
-   **按区间的右端点升序排序？** 这是解决该问题的**正确贪心策略**。

**为什么按右端点排序是最优的？**
当我们决定要放置一个点来覆盖某个区间 `[a, b]` 时，这个点放在区间的哪个位置最好？答案是放在右端点 `b`。
理由是：对于所有尚未被覆盖且与 `[a, b]` 有交集的区间，点 `b` 相较于 `[a, b]` 内的任何其他点，都有最大或至少相等的机会去覆盖它们。换句话说，将点放在区间的“最右边”，可以最大化这个点对“未来”区间（即右端点更大的区间）的潜在覆盖能力。这是一种“将决策推到最后时刻”的思想，从而为未来的选择保留了最大的灵活性。

### 算法步骤

1.  **数据结构**:
    -   定义一个结构体 `Interval`，包含 `start` 和 `end` 两个成员。
    -   创建一个 `Interval` 类型的 `std::vector` 来存储所有 $n$ 个区间。

2.  **数据读取**:
    -   读取区间的总数 $n$。
    -   循环 $n$ 次，读取每个区间的起始值 `a` 和结束值 `b`，并存入向量中。

3.  **排序**:
    -   这是贪心策略的核心。对存储所有区间的向量进行排序。
    -   排序的**主键是 `end`（右端点）**，按**升序**排列。如果右端点相同，可以按左端点升序作为次要排序键，但这对于算法的正确性不是必需的。

4.  **贪心选择**:
    -   初始化所需点的数量 `count = 0`。
    -   初始化一个变量 `last_point_position`，用于记录我们放置的最后一个点的位置。可以将其初始值设为一个不可能的坐标，例如 `-1`。
    -   遍历**排序后**的区间列表：
        -   对于当前遍历到的区间 `current_interval`：
        -   检查这个区间是否已经被我们放置的最后一个点 `last_point_position` 覆盖。
        -   **未被覆盖的条件是**: `current_interval.start > last_point_position`。
        -   如果当前区间**未被覆盖**：
            -   这意味着我们必须放置一个新的点来覆盖它。
            -   根据我们的贪心策略，这个新点应该放在 `current_interval.end`。
            -   `count` 加 1。
            -   更新 `last_point_position = current_interval.end`。
        -   如果当前区间已被覆盖（即 `current_interval.start <= last_point_position`），则无需任何操作，继续检查下一个区间。

5.  **输出结果**:
    -   遍历完成后，`count` 的值就是最少需要选择的点的数量。

这个算法的时间复杂度主要由排序决定，为 $O(N \log N)$。
