## 问题200 题解

### 题目分析

本题的核心是将一个由 1 到 N 数字构成的排列，看作是一个巨大的计数系统。火星人通过改变手指的排列顺序来表示一个数，这本质上是利用了**排列的字典序**。

一个 N 个元素的排列共有 N! 种。我们可以将这 N! 种排列按照字典序从小到大排序，每一种排列就对应一个唯一的排名（从 0 到 N!-1）。

题目要求我们将一个给定的排列加上一个小数 M，实际上就是要求我们找出这个排列在字典序上**向后移动 M 位**得到的新排列。

### 解题思路

这个问题可以直接转化为：**求一个给定排列的、字典序上的第 M 个后继排列**。

C++ 的标准模板库（STL）中提供了一个完美的工具来解决这个问题：`next_permutation` 函数。

1.  **`next_permutation` 函数**：
    *   `next_permutation` 函数可以将一个序列（如 `vector` 或数组）原地修改为其在字典序中的下一个排列。
    *   如果当前排列已经是字典序最大的排列（例如 `5 4 3 2 1`），该函数会返回 `false` 并将序列变为字典序最小的排列（`1 2 3 4 5`）。在其他情况下，它返回 `true`。

2.  **算法步骤**：
    *   首先，读取输入的 N、M 以及初始的 N 个整数排列。
    *   然后，我们执行一个循环，次数为 M。
    *   在循环体内部，我们只做一件事：对存储排列的容器（例如 `std::vector`）调用一次 `next_permutation` 函数。
    *   当循环 M 次结束后，容器中的排列就是我们要求的最终结果。
    *   最后，按格式输出这个新的排列。

### 举例说明

以样例为例：
*   N = 5, M = 3
*   初始排列：`1 2 3 4 5`

1.  **第1次调用 `next_permutation`**：排列变为 `1 2 3 5 4`
2.  **第2次调用 `next_permutation`**：排列变为 `1 2 4 3 5`
3.  **第3次调用 `next_permutation`**：排列变为 `1 2 4 5 3`

循环结束，最终输出 `1 2 4 5 3`，与样例输出一致。

这种方法的算法复杂度为 O(M * N)，对于本题的数据范围来说效率足够高。该解法利用的核心算法是 **`next_permutation`**，它属于 **组合数学** 和 **字典序算法** 的范畴。
