## 问题423 题解

### 题目分析

本题要求我们计算一个正整数的相反数在计算机中的**补码**（Two's Complement）表示。输入的数是以二进制字符串的形式给出的。

这是一个计算机组成原理中的基础概念。对于一个正数 `x`，求其相反数 `-x` 的补码表示，有两种标准方法。

### 解题思路

#### 方法一：按位取反，末位加一

这是最传统的教科书方法：
1.  **按位取反**：将二进制数的每一位都取反（0变1，1变0）。这得到的是**反码**（Ones' Complement）。
2.  **末位加一**：将得到的反码加1。

**示例：`10010`**
1.  按位取反：`01101` (反码)
2.  加一： `01101 + 1 = 01110` (补码)

这个方法在逻辑上是清晰的，但在字符串层面模拟“加一”操作会涉及进位，比较繁琐。

---

#### 方法二：从右到左的快速转换法

这是一个在操作上更简洁、更适合编程实现的技巧：
**从右向左遍历二进制数，找到第一个出现的'1'。这个'1'和它右边的所有位保持不变，而它左边的所有位全部按位取反。**

**示例：`10010`**
1.  从右向左看，依次是 `0`, `1`, ...
2.  第一个 `1` 出现在从右数第2位（索引为1）。
3.  **保持不变部分**：这个 `1` 和它右边的 `0` 保持不变，得到 `...10`。
4.  **按位取反部分**：这个 `1` 左边的部分是 `100`。对它们逐位取反，得到 `011`。
5.  **拼接结果**：将两部分合起来，得到 `01110`。

这个方法与方法一的结果完全等价，但它避免了处理进位的复杂性，可以直接在字符串上进行修改，实现起来非常简单。

#### 实现步骤（基于方法二）
1.  读取输入的二进制字符串`s`。
2.  使用字符串的`rfind('1')`方法找到最右边（也就是第一个）'1'的索引`last_one_pos`。
3.  处理特殊情况：如果找不到'1'（即输入是"0"），则结果还是"0"。
4.  遍历字符串，从索引`0`到`last_one_pos - 1`，将这一部分的字符逐个取反。
5.  从`last_one_pos`到字符串末尾的部分保持不变。
6.  输出修改后的字符串。
