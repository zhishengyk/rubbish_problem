## 问题444 题解

### 题目分析

本题要求我们使用递归的方法计算组合数 $C(m, n)$，即从 `m` 个不同元素中取出 `n` 个元素的方案数。题目给出了组合数的核心递推关系，也称为帕斯卡恒等式（Pascal's Identity），以及两个基本情况。

-   **递推关系**: $C(m,n) = C(m-1,n) + C(m-1,n-1)$
-   **基本情况1**: $C(m,m) = 1$
-   **基本情况2**: $C(m,1) = m$

### 解题思路

题目明确要求使用递归，所以我们直接将给定的数学定义翻译成一个递归函数即可。

#### 1. 递归函数设计

我们定义一个函数，例如 `combinations(m, n)`，它将计算并返回 $C(m, n)$ 的值。这个函数需要能够处理递归的两种情况：基本情况和递归步骤。

-   **递归步骤 (Recursive Step)**:
    当不满足基本情况时，函数将调用自身两次来求解：一次是 `combinations(m-1, n)`，另一次是 `combinations(m-1, n-1)`。然后将这两个结果相加返回。这是帕斯卡恒等式的直接应用。

-   **基本情况 (Base Cases)**:
    递归必须有出口，否则会无限进行下去。我们需要确定递归何时停止。
    1.  如果 `n == m`，根据题目 `C(m,m) = 1`，函数应返回 `1`。
    2.  如果 `n == 1`，根据题目 `C(m,1) = m`，函数应返回 `m`。
    3.  我们还需要考虑一个隐含的基本情况：从 `m` 个元素中取 `0` 个元素，只有一种方法（即什么都不取）。所以 `C(m, 0) = 1`。当递推关系中的 `n` 减少到 `0` 时，需要这个出口。
    4.  另外，如果 `n > m`，组合数无意义或为0。题目中保证 `m > n`，所以我们暂时不用考虑此情况。

综上，我们的递归函数需要检查 `n == 0`，`n == 1` 和 `n == m` 作为递归的终止条件。

### C++代码实现

```cpp
#include <iostream>

long long combinations(int m, int n) {
    // 基本情况：从m个中取0个，只有1种方法
    if (n == 0) {
        return 1;
    }
    // 基本情况：从m个中取m个，只有1种方法
    if (n == m) {
        return 1;
    }
    // 基本情况：从m个中取1个，有m种方法
    if (n == 1) {
        return m;
    }
    
    // 递归步骤：应用帕斯卡恒等式
    return combinations(m - 1, n) + combinations(m - 1, n - 1);
}

int main() {
    int m, n;
    std::cin >> m >> n;
    
    // 由于 m, n <= 20，结果不会超过 long long 的范围
    long long result = combinations(m, n);
    
    std::cout << result << std::endl;
    
    return 0;
}
```

**关于效率**:
这种纯递归的实现非常直观，但效率不高，因为它会反复计算相同的子问题（例如，`combinations(10, 5)` 和 `combinations(10, 6)` 都会去计算 `combinations(9, 5)`）。对于本题给定的 `m, n <= 20` 的小范围数据，这种方法是可以通过的。对于更大的 `m` 和 `n`，就需要使用记忆化搜索（自顶向下的动态规划）或迭代（自底向上的动态规划）来优化。
