## 问题201 题解

### 题目分析

本题要求我们根据一系列比赛得分记录（由 'W' 和 'L' 构成），分别按照 11 分制和 21 分制两种规则，模拟比赛过程并输出每一局的比分。这是一个典型的模拟问题。

### 解题思路

解决这个问题的关键是精确地模拟乒乓球比赛的计分和胜负判断规则。为了代码的复用性，我们可以将计分逻辑封装成一个独立的函数。

1.  **读取输入**：
    *   比赛的得分记录可能分布在多行，并且以字符 'E' 作为结束标志。因此，我们需要先循环读取输入，将所有的 'W' 和 'L' 字符拼接成一个长字符串，直到遇到 'E' 为止。

2.  **设计通用计分函数**：
    *   我们可以创建一个函数，如 `void print_scores(const std::string& all_chars, int win_score)`，它接受完整的得分记录和一局的胜利目标分数（11 或 21）作为参数。
    *   在该函数内部，我们初始化两个变量，`score_a` 和 `score_b`，用于记录当前局的比分。

3.  **模拟计分过程**：
    *   遍历拼接好的完整得分记录字符串。
    *   对于每一个字符：
        *   如果字符是 'W'，则 `score_a` 加 1。
        *   如果字符是 'L'，则 `score_b` 加 1。
    *   在每次得分后，需要检查当前局是否结束。一局比赛结束的条件是：
        *   一方分数达到或超过目标分数（`win_score`）。
        *   **并且**，该方领先对方的分数至少为 2。
        *   即 `(score_a >= win_score || score_b >= win_score) && abs(score_a - score_b) >= 2`。
    *   如果满足结束条件，就输出当前的比分 `score_a:score_b`，然后将 `score_a` 和 `score_b` 重置为 0，为下一局做准备。

4.  **处理最终局**：
    *   当遍历完所有得分记录后，最后一局可能还未满足结束条件。此时，无论比分如何，都需要将这一局的当前比分输出。

5.  **主程序结构**：
    *   首先，完成第一步，读取并整合所有输入。
    *   调用 `print_scores` 函数，传入目标分数 11，处理 11 分制的情况。
    *   输出一个空行。
    *   再次调用 `print_scores` 函数，传入目标分数 21，处理 21 分制的情况。

这个算法完全遵循题目描述的规则进行，属于纯粹的 **模拟**。
