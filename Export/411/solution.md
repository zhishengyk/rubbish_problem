## 问题411 题解

### 题目分析

本题是一个模拟结合排序的综合问题。我们需要根据给定的规则，从n个选手中筛选出进入面试的名单。

核心要求如下：
1.  **排序**：选手需要先按成绩从高到低排序，如果成绩相同，则按报名号从小到大排序。
2.  **划定分数线**：面试分数线由计划录取人数`m`的150%（向下取整）位置的选手成绩决定。
3.  **确定最终名单**：所有成绩不低于面试分数线的选手都将进入面试。
4.  **输出**：先输出分数线和最终面试人数，然后输出完整的面试名单。

### 解题思路

解决这个问题的步骤清晰明了，可以分解为以下几个部分：

1.  **数据结构**：
    -   为了将选手的报名号和成绩绑定在一起处理，定义一个`Contestant`结构体是最佳选择。
    -   `struct Contestant { int id; int score; };`
    -   使用一个`std::vector<Contestant>`来存储所有选手的信息。

2.  **自定义排序**：
    -   `std::sort`函数允许我们提供一个自定义的比较函数，这对于实现复杂排序规则至关重要。
    -   我们需要编写一个比较函数`compareContestants`，其逻辑是：
        -   如果两个选手的成绩不相等，则成绩高的排在前面 (`a.score > b.score`)。
        -   如果成绩相等，则报名号小的排在前面 (`a.id < b.id`)。

3.  **计算与筛选**：
    -   读取所有选手数据并存入向量后，使用`std::sort`和自定义的比较函数对整个向量进行排序。
    -   计算理论上的面试人数 `interview_count = floor(m * 1.5)`。
    -   排序后，第`interview_count - 1`个元素（索引从0开始）的成绩就是面试分数线`cutoff_score`。
    -   确定最终面试人数`actual_count`：由于同分现象，所有成绩大于或等于`cutoff_score`的都入围。我们可以从头遍历排序后的向量，统计所有符合条件的选手，直到遇到第一个分数低于`cutoff_score`的选手为止。

4.  **格式化输出**：
    -   首先，按格式输出`cutoff_score`和`actual_count`。
    -   然后，循环输出向量中前`actual_count`个选手的`id`和`score`。

通过以上步骤，可以完整地解决本题。核心在于结构体的使用和自定义排序函数的编写。
