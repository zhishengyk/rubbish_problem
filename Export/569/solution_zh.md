## 最小字典序对联解法

本题要求我们根据一个上联（数字序列 `S`），生成一个下联（数字序列 `T`），并满足一系列规则，最终目标是使下联 `T` 的字典序最小。

### 规则与目标分析

1.  **一一映射**: 上联中出现过的每一种数字，都必须唯一地对应下联中的一个数字。例如，如果上联中的 `3` 对应下联的 `1`，那么所有 `3` 都要对应 `1`，且上联中其他数字（如`4`）不能再对应 `1`。
2.  **数字排斥**: 下联中使用的数字，不能在上联中出现过。
3.  **字典序最小**: 在所有可能的合法下联中，找到字典序最小的那一个。

“字典序最小”是解题的关键。为了让一个序列的字典序最小，我们必须让它的第一个元素尽可能小；在第一个元素确定的前提下，让第二个元素尽可能小；以此类推。

### 贪心策略

根据字典序最小的目标，我们可以采用一个贪心的策略，从左到右依次确定下联 `T` 的每一个数字。

当我们处理上联的第 `i` 个数字 `S[i]` 时：
*   **情况一：`S[i]` 之前出现过**。
    根据规则1，映射关系必须统一。我们之前肯定已经为 `S[i]` 这个数字确定了一个映射值，我们直接使用这个值即可。
*   **情况二：`S[i]` 是第一次出现**。
    我们需要为 `S[i]` 赋予一个新的、在下联中使用的数字。为了使当前的 `T[i]` 尽可能小（从而保证整体字典序最小），我们应该选择当前**可用的、最小的**正整数。
    *   “可用”的定义是：这个数既不能在上联中出现过（规则2），也不能已经被我们用作下联中其他数字的映射值（规则1）。

### 算法流程

1.  **预处理**:
    *   为了快速判断一个数是否在上联中出现过，我们首先遍历一遍上联 `S`，将其所有数字存入一个哈希集合 `s_numbers` (`std::unordered_set`) 中。

2.  **生成下联**:
    *   我们需要一个数据结构来存储已经建立的映射关系。`std::map<int, int> mapping` 是一个好的选择，它记录了从上联数字到下联数字的映射。
    *   我们还需要一个变量 `next_t_num`，初始化为1，用来寻找下一个可用的最小正整数。
    *   我们从左到右遍历上联 `S` 中的每个数字 `s_num = S[i]`：
        *   **检查映射**: 查看 `s_num` 是否已经在 `mapping` 中。
            *   如果**是**，说明 `s_num` 之前出现过。我们直接从 `mapping` 中取出对应的下联数字，作为 `T[i]` 的值。
            *   如果**否**，说明 `s_num` 是第一次出现。我们需要为它寻找一个映射值：
                1.  从当前的 `next_t_num` 开始，检查它是否可用。
                2.  `while` 循环：如果 `next_t_num` 存在于哈希集合 `s_numbers` 中，说明它被上联占用了，不可用，将 `next_t_num` 加一，继续检查。
                3.  循环结束后，`next_t_num` 就是当前可用的、最小的正整数。
                4.  建立新的映射：`mapping[s_num] = next_t_num`。
                5.  将这个值作为 `T[i]` 的值。
                6.  将 `next_t_num` 加一，为下一次寻找新映射做准备。

3.  **输出**:
    *   将过程中生成的下联序列 `T` 打印出来。

### 代码实现

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
#include <map>

void solve() {
    int n;
    std::cin >> n;
    std::vector<int> s(n);
    std::unordered_set<int> s_numbers; // 存储上联出现过的所有数字
    for (int i = 0; i < n; ++i) {
        std::cin >> s[i];
        s_numbers.insert(s[i]);
    }

    // 存储上联->下联的映射关系
    std::map<int, int> mapping;
    std::vector<int> t(n);
    int next_t_num = 1; // 指向下一个可用的最小正整数

    for (int i = 0; i < n; ++i) {
        int current_s_num = s[i];
        if (mapping.count(current_s_num)) {
            // 这个上联数字之前出现过，直接使用已有的映射
            t[i] = mapping[current_s_num];
        } else {
            // 第一次出现的上联数字，需要寻找一个新的、可用的下联数字
            while (s_numbers.count(next_t_num)) {
                // 这个数字被上联占用了，不可用
                next_t_num++;
            }
            // 找到了，建立映射
            mapping[current_s_num] = next_t_num;
            t[i] = next_t_num;
            
            // 为下一次寻找做准备
            next_t_num++;
        }
    }

    for (int i = 0; i < n; ++i) {
        std::cout << t[i] << (i == n - 1 ? "" : " ");
    }
    std::cout << std::endl;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    solve();
    return 0;
}
```
