## 问题502 题解

### 题目分析

这个问题要求我们移走至多 `M` 块岩石，来最大化剩下岩石之间的最短跳跃距离。这是一个典型的“最大化最小值”问题，是二分答案算法的经典应用场景。

### 解题思路

直接去寻找那个最优的移除方案来最大化最短距离是非常困难的。但是，如果我们反过来问：**“能否通过移除M块石头，使得最短跳跃距离不小于 `d`？”**，这个问题就变得容易回答了。这启发我们使用二分法来搜索答案。

1.  **二分答案**：
    -   我们对“最短跳跃距离”这个答案进行二分搜索。搜索范围可以是 `[1, L]`。
    -   对于二分出的一个候选答案 `d`，我们去检验它的可行性。

2.  **检验函数 `check(d)`**：
    -   `check(d)` 的任务是判断：我们是否能通过移除最多 `M` 块石头，使得所有相邻岩石间的距离都 `>= d`。
    -   我们可以使用贪心策略来做这个判断：
        -   从起点开始，我们依次考虑每一块岩石。
        -   我们维护一个 `last_stone_pos` 变量，记录上一块**保留**的岩石的位置（初始为起点0）。
        -   当检查到第 `i` 块岩石时，我们计算它与 `last_stone_pos` 的距离。
        -   **如果 `distance < d`**：说明这块岩石离上一块保留的岩石太近了，不满足最短距离为 `d` 的要求。为了让后面的石头尽可能满足条件，我们应该贪心地移走当前这块岩石。
        -   **如果 `distance >= d`**：这块岩石可以保留，因为它满足了与前一块保留岩石的距离要求。我们更新 `last_stone_pos` 为当前岩石的位置。
    -   我们统计整个过程中需要移走的岩石数量。如果这个数量小于等于 `M`，那么 `d` 就是一个可行的最短距离，`check(d)` 返回 `true`。否则返回 `false`。

3.  **更新二分边界**：
    -   如果 `check(d)` 返回 `true`，说明 `d` 是一个可行的值，我们也许还能找到更大的可行值。所以，我们记录下当前的结果，并尝试在 `[d+1, L]` 的范围里继续搜索，即 `left = d + 1`。
    -   如果 `check(d)` 返回 `false`，说明 `d` 太大了，无法实现。我们需要一个更小的值，所以在 `[1, d-1]` 的范围里搜索，即 `right = d - 1`。

通过不断迭代，我们就能找到最大的可行的 `d`。为了方便处理，可以将起点和终点也看作是岩石，加入到岩石序列中。
