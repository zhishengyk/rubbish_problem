## 问题499 题解

### 题目分析

这个问题要求我们在一个升序排列的数列中，找到第一个大于或等于给定值 `x` 的元素。这是一个非常经典的查找问题，二分查找是解决这个问题的标准且高效的方法。

### 解题思路

由于数列是升序的，我们可以利用这个有序性进行二分查找。

#### 方法一：使用C++标准库 `std::lower_bound`

C++标准库 `<algorithm>` 中提供了一个非常方便的函数 `std::lower_bound`，它的功能正是查找有序区间中第一个不小于（即大于或等于）给定值的元素。

1.  **调用函数**：`auto it = std::lower_bound(array.begin(), array.end(), x);`
2.  **处理返回值**：
    -   `lower_bound` 返回一个迭代器。
    -   如果这个迭代器不等于数组的 `end()` 迭代器，说明找到了满足条件的元素，`*it` 就是我们要找的值。
    -   如果迭代器等于 `end()`，说明数组中所有元素都比 `x` 小，不存在满足条件的元素，此时应输出 -1。

这种方法代码简洁，不易出错，且效率很高，时间复杂度为 $O(\log n)$。

#### 方法二：手动实现二分查找

我们也可以自己编写二分查找的逻辑。

1.  **初始化**：设置左右指针 `left = 0`, `right = n-1`。
2.  **循环查找**：当 `left <= right` 时：
    -   计算中间位置 `mid = left + (right - left) / 2`。
    -   如果 `array[mid] >= x`，说明 `mid` 位置的元素以及它右边的元素都可能是答案，但我们想找最左边（第一个）的，所以我们记录下当前的可能答案，并尝试在左半部分继续寻找，即 `right = mid - 1`。
    -   如果 `array[mid] < x`，说明 `mid` 位置以及它左边的元素都太小了，答案一定在右半部分，即 `left = mid + 1`。
3.  **输出结果**：循环结束后，输出我们记录下的答案。如果从未找到满足条件的元素，则输出-1。
