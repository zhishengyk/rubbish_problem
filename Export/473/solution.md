## 问题473 题解

### 题目分析

这是一个经典的**分数背包问题**。我们拥有一个容量固定的背包（口袋），以及若干种物品（金属）。每种物品都有其总重量和总价值，并且可以被任意分割。我们的目标是选择装入背包的物品（及数量），以使背包内物品的总价值最大化。

该问题的核心特征是“物品可以被任意分割”，这使得我们可以采用简单的贪心策略来求解，而无需使用更复杂的动态规划（动态规划通常用于物品不能分割的0-1背包问题）。

### 贪心策略

对于分数背包问题，最优解总是可以通过一个固定的贪心策略获得：**优先选取性价比最高的物品**。在本题的上下文中，“性价比”即为金属的**单位重量的价值**（俗称“单价”）。

因此，我们的策略是：
1.  计算出每种金属的单位价值。
2.  按照单位价值从高到低的顺序，依次将金属装入背包。
3.  如果一种金属可以全部装下，就全部装入。如果只能装下一部分，就装满背包的剩余容量。

### 算法步骤

1.  **数据结构**:
    -   为了方便地将金属的各种属性关联起来，我们可以定义一个结构体 `Metal`，包含 `weight`（总重量）, `value`（总价值）, 和 `unit_value`（单位价值）三个成员。
    -   创建一个 `Metal` 类型的 `std::vector` 来存储所有种类的金属。

2.  **数据读取与单价计算**:
    -   外层循环处理 $k$ 组测试数据。
    -   对于每组数据，首先读取背包容量 $w$ 和金属种类数 $s$。
    -   然后在一个循环中读取 $s$ 种金属的重量 $n_i$ 和价值 $v_i$。
    -   在读取的同时，计算每种金属的单位价值：
        `unit_value = (double)v_i / n_i;`
        (注意：必须使用浮点数，如 `double`，来进行除法运算，以确保单价的精确性。)
    -   将这些信息存入 `Metal` 向量。

3.  **按单位价值排序**:
    -   这是贪心策略的核心。对 `Metal` 向量进行**降序排序**，排序的依据是 `unit_value`。

4.  **贪心装包**:
    -   初始化总价值 `max_value = 0.0` 和背包剩余容量 `remaining_capacity = w`。
    -   遍历**排序后**的金属向量（从单位价值最高的开始）：
        -   如果 `remaining_capacity == 0`，说明背包已满，可以提前结束。
        -   对于当前遍历到的金属 `current_metal`：
            -   **情况 A: 背包可以完全装下当前金属**
                -   如果 `current_metal.weight <= remaining_capacity`：
                    -   将该金属全部装入。
                    -   `max_value += current_metal.value`。
                    -   更新剩余容量：`remaining_capacity -= current_metal.weight`。
            -   **情况 B: 背包只能装下当前金属的一部分**
                -   如果 `current_metal.weight > remaining_capacity`：
                    -   只装入 `remaining_capacity` 重量的金属。
                    -   增加的价值为 `remaining_capacity * current_metal.unit_value`。
                    -   `max_value += remaining_capacity * current_metal.unit_value`。
                    -   此时背包已满，`remaining_capacity` 变为0。

5.  **输出结果**:
    -   遍历结束后，`max_value` 就是能获得的最大价值。
    -   根据题目要求，使用格式化输出，将结果精确到小数点后两位。
