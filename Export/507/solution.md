## 问题507 题解

### 题目分析

这个问题要求我们找到一个最大的整数高度 `H`，使得将所有高于 `H` 的树木部分锯下后，收集到的木材总量至少为 `M`。

这是一个典型的“在单调函数上求解”的问题，非常适合使用二分答案算法。

### 解题思路

1.  **单调性分析**：
    -   我们可以观察到，设定的切割高度 `H` 和最终能获得的木材总量 `W` 之间存在一个单调关系。
    -   如果 `H` 越高，每棵树被切割掉的部分就越少，因此总木材量 `W` 就越少。反之，`H` 越低，`W` 就越多。
    -   这种单调性是使用二分答案的前提。

2.  **二分答案**：
    -   我们不是直接去寻找那个最优的 `H`，而是对 `H` 的可能取值范围进行二分搜索。`H` 的取值范围是 `[0, 最高的树的高度]`。
    -   对于二分出的一个候选高度 `h_candidate`，我们去检验它是否可行。

3.  **检验函数 `check(h)`**：
    -   `check(h)` 的任务是判断：如果切割高度设为 `h`，我们能获得的木材总量是否**至少**为 `M`。
    -   这个检验很简单：我们遍历所有的树。对于每一棵高度为 `tree_height` 的树，如果 `tree_height > h`，那么它能贡献 `tree_height - h` 的木材。
    -   我们将所有树贡献的木材加起来，得到一个 `total_wood`。
    -   如果 `total_wood >= M`，说明 `h` 是一个可行的（或者可能偏低）的高度，`check(h)` 返回 `true`。否则返回 `false`。

4.  **更新二分边界**：
    -   如果 `check(h_candidate)` 返回 `true`，说明 `h_candidate` 是一个可行的解。但我们想找的是**最大**的 `H`，所以我们应该尝试更高的 `H`。我们记录下当前可行的解 `ans = h_candidate`，然后在 `[h_candidate + 1, ...]` 的范围里继续搜索，即 `left = h_candidate + 1`。
    -   如果 `check(h_candidate)` 返回 `false`，说明高度 `h_candidate` 太高了，得到的木材不够。我们需要降低高度，所以在 `[..., h_candidate - 1]` 的范围里搜索，即 `right = h_candidate - 1`。

通过不断迭代，我们就能逼近并找到满足条件的最大整数 `H`。

**算法复杂度**：
-   二分搜索的范围是 `[0, max_height]`，迭代次数约为 $O(\log(\text{max\_height}))$。
-   每次 `check` 函数需要遍历 `N` 棵树，时间复杂度为 $O(N)$。
-   总的时间复杂度是 $O(N \log(\text{max\_height}))$。
