## 问题523 题解

### 题目分析

本题要求我们统计一个数组中，所有满足“内部元素乘积严格小于 $k$”的**连续子数组**的数量。

一个朴素的解法是使用两层循环枚举所有连续子数组的起点和终点，然后计算它们的乘积，但这会导致 $O(n^2)$ 的时间复杂度，在 $N$ 达到 $3 \times 10^4$ 的情况下会超时。我们需要一个更高效的线性时间算法。

### 解题思路：滑动窗口（双指针法）

由于数组中的所有元素都是正整数（$\ge 1$），这为我们使用**滑动窗口**技巧提供了理想的条件。当窗口向右扩展时，窗口内元素的乘积是单调不减的。

我们可以使用两个指针，`left` 和 `right`，来定义一个动态的窗口 `[left...right]`。算法的核心思想是：对于每一个 `right` 指针，我们找到一个最靠左的 `left` 指针，使得 `[left...right]` 这个窗口内的乘积刚好满足 `< k` 的条件。

#### 算法步骤

1.  **初始化**:
    -   `left = 0` (窗口左边界)
    -   `count = 0` (满足条件的子数组总数)
    -   `current_product = 1` (当前窗口内元素的乘积)

2.  **主循环 (扩大窗口)**:
    -   我们使用一个 `for` 循环，让 `right` 指针从 `0` 遍历到 `N-1`。
    -   在循环的每一步中，将 `nums[right]` 乘入当前窗口的乘积中：
        `current_product *= nums[right];`

3.  **内层循环 (收缩窗口)**:
    -   在扩大窗口后，`current_product` 可能会变得大于或等于 $k$。
    -   我们使用一个 `while` 循环来检查并处理这种情况：
        `while (current_product >= k && left <= right)`
        -   只要乘积不满足 `< k` 的条件，我们就需要从左侧收缩窗口，直到它再次满足为止。
        -   将 `nums[left]` 从乘积中移除：`current_product /= nums[left];`
        -   移动左边界：`left++;`
    -   这个 `while` 循环确保了在执行下一步计数时，窗口 `[left...right]` 始终是满足 `product < k` 的。

4.  **计数**:
    -   当 `while` 循环结束后，我们得到了一个以 `right` 为右端点的、乘积 `< k` 的最长连续子数组，其左端点为 `left`。
    -   这意味着，**所有以 `right` 为右端点，且左端点在 `[left, right]` 区间内的子数组**，它们的乘积都必定小于 $k$。
    -   这些子数组包括 `[right]`, `[right-1, right]`, ..., `[left, right]`。
    -   它们的数量共有 `right - left + 1` 个。
    -   我们将这个数量累加到 `count` 中：
        `count += right - left + 1;`

5.  **最终结果**:
    -   外层循环结束后，`count` 就是所有满足条件的连续子数组的总数。

这个算法的时间复杂度为 $O(N)$，因为 `left` 和 `right` 两个指针都各自只对数组进行了一次从头到尾的单向遍历。
