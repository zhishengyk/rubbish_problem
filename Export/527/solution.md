## 问题527 题解

### 题目分析

本题要求我们在一个由字符 '1', '2', '3' 组成的字符串中，找到一个**最短的连续子串**，该子串必须**同时包含**这三个字符。这是一个经典的**最小窗口子串（Minimum Window Substring）**问题的一个简化版本。

一个朴素的解法是枚举所有可能的子串起点和终点，然后检查每个子串是否满足条件，但这会导致 $O(|s|^2)$ 的时间复杂度，对于本题的数据规模来说会超时。正确的解法是使用**滑动窗口（或双指针）**技巧，可以在线性时间内解决问题。

### 解题思路：滑动窗口

我们将使用两个指针，`left` 和 `right`，来维护一个动态的“窗口”。算法的思路是：
1.  不断向右移动 `right` 指针来**扩大窗口**。
2.  每当窗口内的子串满足“包含1,2,3”的条件时，我们就记录下当前的长度，并尝试从左侧向右移动 `left` 指针来**收缩窗口**，以寻找一个可能更短的、但仍然满足条件的子串。
3.  重复这个过程，直到 `right` 指针遍历完整个字符串。

#### 数据结构
为了高效地判断当前窗口是否满足条件，我们需要一个数据结构来追踪窗口内 '1', '2', '3' 的出现次数。一个大小为4的**频率数组（`counts`）**非常适合这个任务，其中 `counts[1]`, `counts[2]`, `counts[3]` 分别记录对应字符的出现次数。

#### 算法步骤

1.  **初始化**:
    -   `left = 0` (窗口左边界)。
    -   `min_length = infinity` (用于存储找到的最短长度，初始为极大值)。
    -   `counts[4] = {0}` (频率数组)。
    -   `distinct_count = 0` (记录窗口内不同字符的种类数，'1'/'2'/'3')。

2.  **主循环 (扩大窗口)**:
    -   使用一个 `for` 循环，让 `right` 指针从 `0` 遍历到字符串末尾。
    -   对于 `right` 指向的字符 `char_right`:
        -   将其计入频率数组：`counts[char_right - '0']++`。
        -   如果 `char_right` 是第一次出现（即 `counts` 中它的计数从0变为1），则 `distinct_count++`。

3.  **内层循环 (收缩窗口)**:
    -   在扩大窗口后，使用一个 `while` 循环来检查窗口是否满足条件并尝试收缩：
        `while (distinct_count == 3)`
        -   **更新最小长度**: 如果条件满足（我们集齐了三种字符），说明找到了一个可行解。我们更新 `min_length`：
            `min_length = min(min_length, right - left + 1);`
        -   **收缩窗口**: 尝试找到更短的解。我们处理窗口最左侧的字符 `char_left = s[left]`：
            -   将其频率减一：`counts[char_left - '0']--`。
            -   如果减一后，`char_left` 在窗口内的计数变为0，说明我们失去了一种必需的字符，因此 `distinct_count--`。
            -   将左边界右移：`left++`。
    -   这个 `while` 循环会一直执行，直到窗口不再满足“包含三种字符”的条件，此时我们需要继续扩大窗口（即 `right++`）来寻找下一个可行解。

4.  **处理最终结果**:
    -   外层循环结束后，`min_length` 中就保存了最短的长度。
    -   如果 `min_length` 仍然是我们初始设置的极大值，说明从未找到过满足条件的子串。在这种情况下，根据题意应返回 `0`。
    -   否则，返回 `min_length`。

该算法的时间复杂度为 $O(|s|)$，对于多组测试数据，总复杂度为所有字符串长度之和，满足题目要求。
