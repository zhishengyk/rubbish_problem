## 问题443 题解

### 题目分析

本题描述了一个关于牛群增长的模型，要求我们计算第 `n` 年牛的总数。这是一个典型的递推关系问题。

牛的繁殖规则如下：
1.  **初始母牛**：从第2年开始，每年生一头小母牛。
2.  **新生母牛**：从它出生的第4个年头开始，每年生一头小母牛。

我们需要处理多组输入，直到输入为0时结束。

### 解题思路

我们可以通过动态规划来解决这个问题。关键是建立一个正确的递推关系。

#### 1. 定义状态

设 `dp[i]` 为第 `i` 年年初时牛的总数。

#### 2. 分析递推关系

第 `i` 年的牛总数等于第 `i-1` 年的牛数，加上在第 `i` 年年初新出生的牛数。
`dp[i] = dp[i-1] + (new_cows_in_year_i)`

现在的问题是，如何计算 `new_cows_in_year_i`？
新牛是由所有进入生育年龄的母牛所生。
-   **初始母牛**：题目说它从第2年开始生。
-   **小母牛**：从它出生的第4个年头开始生。
    -   一头在第 `j` 年年初出生的小母牛，在第 `j+1` 年是第2个年头，第 `j+2` 年是第3个年头，第 `j+3` 年是第4个年头。所以它从第 `j+3` 年开始生育。
    -   换句话说，在第 `i` 年能生育的牛，必须是在第 `i-3` 年或更早之前就已经出生了。
    -   因此，在第 `i` 年新出生的牛的数量，就等于在第 `i-3` 年年初时牛的总数 `dp[i-3]`。(这里我们假设初始母牛也符合这个规律，通过调整基本情况来适配)

将这个结论代入，我们得到递推关系：
**`dp[i] = dp[i-1] + dp[i-3]`**  (对于 `i >= 4`)

#### 3. 确定基本情况 (Base Cases)

我们需要手动计算出前几年的牛数来启动递推。

-   **第1年**: 只有1头初始母牛。 `dp[1] = 1`。
-   **第2年**: 初始母牛生了1头。总数 = 1 (旧) + 1 (新) = 2。 `dp[2] = 2`。
-   **第3年**: 初始母牛又生了1头。第2年生的牛还不能生。总数 = 2 (旧) + 1 (新) = 3。 `dp[3] = 3`。
-   **第4年**: 初始母牛生了1头。第2年生的牛现在是第3个年头，到第4个年头才生。不对，"从第四个年头开始"，意味着满3岁就开始生。
    -   牛A在第1年出生，第2年1岁，第3年2岁，第4年3岁，在第4年年初可以生。
    -   所以在第4年，初始母牛可以生，在第2年出生的牛也可以生。
    -   Let's retrace:
        -   Year 1: 1 (Cow A)
        -   Year 2: 2 (A, B=A's child)
        -   Year 3: 3 (A, B, C=A's child)
        -   Year 4: 4 (A, B, C, D=A's child). Cow B is now in its 3rd year of life (age 2), not old enough. The description "第四个年头" (fourth year) implies age 3.
        -   Year 5: `dp[4]` + (new cows). Who gives birth? Cow A gives birth. Cow B (born Y2) is now in its 4th year, so it gives birth. Total new cows = 2. Total = 4 + 2 = 6.
    -   Let's check the formula:
        -   `dp[4] = dp[3] + dp[1] = 3 + 1 = 4`. Correct.
        -   `dp[5] = dp[4] + dp[2] = 4 + 2 = 6`. Correct.
    -   The formula `dp[i] = dp[i-1] + dp[i-3]` seems to have an off-by-one issue based on my second interpretation. Let's re-verify the simpler one.
    -   Let's trust the first derivation `f(i) = f(i-1) + f(i-3)`
    -   Base Cases: `f(1)=1`, `f(2)=2`, `f(3)=3`.
    -   `f(4) = f(3) + f(1) = 3 + 1 = 4`.
    -   `f(5) = f(4) + f(2) = 4 + 2 = 6`.
    -   The simpler recurrence seems correct.

### 算法实现

1.  **预计算**：由于 `n` 的最大值是54，我们可以预先计算出所有 `dp[1]` 到 `dp[54]` 的值并存储在一个数组或 `vector` 中。
2.  **初始化**：设置 `dp[1]=1`, `dp[2]=2`, `dp[3]=3`。
3.  **迭代计算**：使用循环从 `i = 4` 到 `54`，根据 `dp[i] = dp[i-1] + dp[i-3]` 计算所有值。
4.  **处理输入**：
    -   使用 `while` 循环读取 `n`。
    -   如果 `n` 为0，则终止循环。
    -   对于每个 `n`，直接从预计算的数组中查找 `dp[n]` 并输出。

由于 `n` 的值不大，但结果数值可能会增长得很快，使用 `long long` 来存储牛的数量是安全的做法。
