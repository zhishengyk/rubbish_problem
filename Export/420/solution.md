## 问题420 题解

### 题目分析

本题要求计算一系列36进制汽车牌照中，数值上最接近的两个牌照之间的差值。核心任务可以分解为三个步骤：
1.  **解析**：从每个牌照字符串（如"SD12345"）中提取出有效的36进制数值部分（"12345"）。
2.  **转换**：将所有提取出的36进制数转换为我们熟悉的十进制数，以便进行比较。
3.  **查找**：在所有转换后的十进制数中，找到差值最小的一对。

### 解题思路

一个清晰高效的解法是“先转换，再排序，最后查找”。

1.  **36进制转十进制**：
    -   首先需要一个函数，能够将一个36进制的字符串（由'0'-'9'和'A'-'Z'组成）转换为十进制整数。
    -   这个函数需要一个辅助部分，用于将单个字符（如'9', 'A', 'Z'）转换为对应的数值（9, 10, 35）。
    -   转换的核心是“霍纳法则”：从字符串最高位开始，`decimal = decimal * 36 + current_digit_value`，循环累加直到处理完所有字符。

2.  **数据处理流程**：
    -   创建一个`std::vector<long long>`，用于存储所有牌照转换后的十进制值。
    -   循环读取每一行输入的牌照字符串。
    -   对于每个字符串，使用`.substr(2, 5)`方法提取出除"SD"前缀外的后5位。
    -   调用第一步中实现的转换函数，将这5位36进制数转换为十进制`long long`，并存入`vector`中。

3.  **查找最小差值**：
    -   **关键思想**：如果一个数组是**有序的**，那么差值最小的两个元素必然是**相邻的**。
    -   因此，最高效的方法是先对存储所有十进制值的`vector`进行升序排序 `std::sort`。
    -   排序后，只需遍历一次数组，比较所有相邻元素（`vec[i]` 和 `vec[i-1]`）的差值。
    -   维护一个`min_diff`变量，初始设为一个极大的值（如`LLONG_MAX`），在遍历过程中不断更新它，最终得到全局的最小差值。

4.  **输出**：
    -   输出最终计算出的`min_diff`。
    -   注意处理边界情况，例如输入的牌照数量少于2个，此时无法计算差值。

这个方案将问题分解得非常清晰，每一步都使用标准且高效的算法，能够很好地解决问题。
