## 问题511 题解

### 题目分析

这个问题要求我们找到数轴上的一个连续区间，这个区间包含所有品种的奶牛，并且区间的长度（即最大坐标与最小坐标的差）最小。

这是一个经典的**滑动窗口**问题。我们的目标是找到一个“最小可行区间”。

### 解题思路

1.  **预处理**：
    -   首先，我们需要知道总共有多少个不同的奶牛品种。我们可以遍历一遍所有奶牛，用一个 `std::set` 来统计不同品种 `ID` 的数量。
    -   最重要的一步是，我们将所有奶牛按照她们的坐标 `X` 进行**升序排序**。这使得我们可以从左到右地考虑连续区间的奶牛。

2.  **滑动窗口算法**：
    -   我们使用两个指针 `left` 和 `right`，都从排序后数组的开头开始。这两个指针定义了我们的“滑动窗口”。
    -   我们还需要一个数据结构（例如哈希表 `std::map`）来记录当前窗口内每个品种的奶牛数量，我们称之为 `window_counts`。
    -   我们还需要一个计数器 `unique_breeds_in_window` 来记录当前窗口中不同品种的总数。

3.  **算法流程**：
    -   **扩大窗口**：我们不断地将 `right` 指针向右移动，把新的奶牛 `cows[right]` “拉”进窗口。
        -   每拉入一头牛，就更新 `window_counts` 中对应品种的数量。
        -   如果这个品种的数量从0变为1，说明我们找到了一个新的品种，就将 `unique_breeds_in_window` 加1。
    -   **检查与收缩窗口**：
        -   一旦 `unique_breeds_in_window` 等于总的品种数 `total_breeds`，就意味着当前窗口 `[left, right]` 是一个**可行解**（它包含了所有品种）。
        -   我们计算当前窗口的成本 `cost = cows[right].x - cows[left].x`，并用它来更新全局的最小成本 `min_cost`。
        -   在找到一个可行解后，我们尝试让这个解变得“更优”（即更短）。我们通过将 `left` 指针向右移动来**收缩窗口**。
        -   每当一头牛 `cows[left]` “离开”窗口时，我们更新 `window_counts`。如果一个品种的数量从1变为0，说明我们失去了一个必需的品种，就将 `unique_breeds_in_window` 减1。
        -   只要窗口仍然是可行的（`unique_breeds_in_window == total_breeds`），我们就继续收缩 `left` 并更新 `min_cost`。
    -   当窗口不再可行时，我们停止收缩 `left`，返回到扩大窗口的步骤，继续移动 `right`，寻找下一个可行的大窗口。

4.  **结束**：当 `right` 指针到达数组末尾时，整个过程结束，`min_cost` 中存储的就是最终的答案。

**算法复杂度**：
-   排序：$O(N \log N)$
-   滑动窗口：`left` 和 `right` 指针都最多遍历数组一次，所以这部分是 $O(N)$。
-   总的时间复杂度是 $O(N \log N)$。
