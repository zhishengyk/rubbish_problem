## 问题501 题解

### 题目分析

这个问题是经典的“两数之和”（Two Sum）问题的一个变种。我们需要在一个整数数组中找到两个数，它们的和等于一个给定的目标值 `m`。此外，题目还要求在有多个解的情况下，选择其中较小数更小的那个解。

### 解题思路

解决这个问题的经典方法是“排序 + 双指针”。

1.  **排序**：
    -   首先，对输入的整数数组进行升序排序。
    -   排序是这个算法的关键。它不仅使得我们可以用双指针高效地查找，还自然地满足了“选择较小数更小的”这一要求。因为我们总是从最小的数开始尝试。

2.  **双指针**：
    -   我们设置两个指针，一个 `left` 指向排序后数组的开头（最小的元素），另一个 `right` 指向数组的末尾（最大的元素）。
    -   在 `left < right` 的条件下进行循环：
        -   计算 `sum = array[left] + array[right]`。
        -   **如果 `sum == m`**：我们找到了一个解。由于数组是排序的，`array[left]` 是我们当前能找到的最小的数，所以这个解就是题目所求的最优解。直接输出 `array[left]` 和 `array[right]` 并结束程序。
        -   **如果 `sum < m`**：说明当前的和太小了。为了增大和，我们需要一个更大的数。由于 `array[right]` 已经是最大的了，我们只能尝试将 `left` 指针向右移动一位，即 `left++`。
        -   **如果 `sum > m`**：说明当前的和太大了。为了减小和，我们需要一个更小的数。由于 `array[left]` 已经是最小的了，我们只能尝试将 `right` 指针向左移动一位，即 `right--`。

3.  **无解情况**：
    -   如果循环结束（即 `left >= right`）还没有找到和为 `m` 的数对，那就说明不存在这样的解。输出 "No"。

**算法复杂度**：
-   排序的时间复杂度是 $O(n \log n)$。
-   双指针遍历的时间复杂度是 $O(n)$。
-   总的时间复杂度由排序决定，为 $O(n \log n)$。

**另一种方法（哈希表）**：
-   我们也可以用哈希表来解决。遍历数组，对于每个数 `x`，检查 `m-x` 是否在哈希表中。这种方法平均时间复杂度是 $O(n)$，但它不方便处理“选择较小数更小的”这个要求，需要额外的逻辑。因此，对于本题，排序+双指针是更优的选择。
