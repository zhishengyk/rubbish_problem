## 问题510 题解

### 题目分析

这个问题要求我们将一个连续的每日开销序列分成 `M` 个“fajo月”（即M个连续的段），并使得开销最多的那个月的总开销尽可能少。

这与问题509“均分数列”是同一个问题模型，是一个经典的“最大值最小化”问题，其标准解法是二分答案。

### 解题思路

1.  **问题抽象**：将N天的开销看作一个长度为N的数列，将M个fajo月看作将数列分成M个连续的子段。目标是最小化所有子段和中的最大值。

2.  **单调性分析**：
    -   “最大月度开销”这个值具有单调性。如果我们允许的“最大月度开销” `X` 越大，我们完成划分所需的月份就越少（或不变）。反之，如果 `X` 越小，我们需要的月份就越多。
    -   这种单调性是应用二分答案的基础。

3.  **二分答案**：
    -   我们对“最大月度开销”这个答案进行二分搜索。
    -   搜索的下界是单日最高开销（因为每个月至少包含一天），上界是N天总开销（这是只分一个月的情况）。
    -   对于二分出的一个候选值 `X`，我们去检验它的可行性。

4.  **检验函数 `check(X)`**：
    -   `check(X)` 的任务是判断：我们能否将N天的开销分成**不超过 `M` 个月**，同时保证**每个月的开销都不大于 `X`**。
    -   我们可以用贪心策略来做这个判断，计算出在满足“每月开销不大于X”的条件下，**最少需要**多少个月：
        -   遍历每日开销，维护一个 `current_month_expense` 记录当前月的开销，以及一个 `month_count` 记录已划分的月份数（初始为1）。
        -   对于一天的开销 `daily_expense`，如果 `current_month_expense + daily_expense <= X`，则可以把它计入当前月。
        -   如果 `current_month_expense + daily_expense > X`，则当前月无法再承担这一天的开销。我们必须结束当前月，开启一个新月。即 `month_count++`，并且新月的开销从 `daily_expense` 开始。
    -   遍历结束后，我们就得到了最少需要的月份。如果这个月份数小于等于 `M`，说明 `X` 是一个可行的上限，`check(X)` 返回 `true`。

5.  **更新二分边界**：
    -   如果 `check(X)` 返回 `true`，说明 `X` 可行，我们尝试寻找更小的上限。记录 `ans = X`，并更新 `right = X - 1`。
    -   如果 `check(X)` 返回 `false`，说明 `X` 太小了，无法在 `M` 个月内完成。我们需要更大的上限，更新 `left = X + 1`。

最终，`ans` 中存储的就是满足条件的最小的“最大月度开销”。

**算法复杂度**：
-   总的时间复杂度是 $O(N \log(\text{total\_expense}))$。
