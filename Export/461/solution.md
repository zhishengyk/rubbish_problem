## 问题461 题解

### 题目分析

本题要求计算两个正整数 $n$ 和 $m$ 的商，并且需要将结果精确到小数点后100位。由于标准的浮点数据类型（如 `double`）无法提供如此高的精度，我们必须手动模拟除法过程来逐位计算小数部分。这本质上是一个**高精度小数**的计算问题。

### 解题思路

解决这个问题的关键是模拟我们用笔和纸进行长除法时，求小数部分的过程。

#### 算法步骤

1.  **计算并输出整数部分**:
    -   首先，进行一次常规的整数除法，得到商的整数部分：`integer_part = n / m`。
    -   直接输出这个 `integer_part`，并在其后紧跟一个小数点 `.`。

2.  **计算初始余数**:
    -   为了开始小数部分的计算，我们需要知道整数除法完成后剩下的余数：`remainder = n % m`。
    -   这个余数是计算小数第一位的基础。

3.  **循环计算小数部分**:
    -   我们需要一个循环来生成小数点后的100位数字。这个循环将执行100次。
    -   在每一次循环中，我们模拟手算时“在余数后补0再进行除法”的步骤：
        -   **将被除数“扩大”**: 将当前的 `remainder` 乘以10。
            `remainder = remainder * 10;`
        -   **计算当前小数位**: 用这个扩大后的 `remainder` 除以 `m`，得到的商就是小数部分的当前位。
            `current_digit = remainder / m;`
            我们直接输出这个 `current_digit`。
        -   **更新余数**: `remainder` 对 `m` 取模，得到的值将作为下一轮循环的初始余数。
            `remainder = remainder % m;`
    -   这个过程重复100次，我们就能得到100位精确的小数。

**示例 (计算 1/8)**:
1.  **整数部分**:
    -   `1 / 8 = 0`。输出 "0."。
    -   `remainder = 1 % 8 = 1`。
2.  **小数部分 (循环3次为例)**:
    -   **第1位**:
        -   `remainder = 1 * 10 = 10`。
        -   `digit = 10 / 8 = 1`。输出 "1"。
        -   `remainder = 10 % 8 = 2`。
    -   **第2位**:
        -   `remainder = 2 * 10 = 20`。
        -   `digit = 20 / 8 = 2`。输出 "2"。
        -   `remainder = 20 % 8 = 4`。
    -   **第3位**:
        -   `remainder = 4 * 10 = 40`。
        -   `digit = 40 / 8 = 5`。输出 "5"。
        -   `remainder = 40 % 8 = 0`。
3.  **最终结果 (保留3位)**: `0.125`。

这个算法逻辑清晰，通过简单的整数运算模拟了小数除法，可以达到任意指定的精度。
