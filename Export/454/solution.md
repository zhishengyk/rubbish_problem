## 问题454 题解

### 题目分析

本题要求我们计算两个非常大的非负整数的乘积。由于输入数字的位数最高可达200位，这超出了标准数据类型（如`long long`）的处理能力。因此，这是一个典型的高精度乘法问题。

### 解题思路

解决高精度乘法的经典方法是模拟小学生做乘法时使用的**竖式乘法**。这个过程可以分解为两个主要步骤：首先是交叉相乘并累加，然后是处理进位。

#### 1. 数据存储与预处理
-   我们使用 `std::string` 来存储输入的两个大数，设为 `A` 和 `B`。
-   为了方便从个位开始计算，我们将 `A` 和 `B` 的字符串**反转**。例如，`"123"` 变为 `"321"`。这样，`A[i]` 就代表 `A` 的第 $10^i$ 位上的数字。

#### 2. 模拟竖式乘法核心逻辑

我们可以创建一个 `std::vector<int>` 类型的 `result` 数组来存储中间计算结果。其长度应足够容纳最终乘积，理论上最大长度为 `len(A) + len(B)`。

1.  **交叉相乘与累加**:
    我们使用两层嵌套循环来模拟 `A` 的每一位与 `B` 的每一位的相乘过程：
    -   外层循环遍历反转后的 `A` 的每一位 `A[i]`。
    -   内层循环遍历反转后的 `B` 的每一位 `B[j]`。
    -   `A[i]` 乘以 `B[j]` 的结果，应该贡献到最终乘积的第 `i+j` 位上。
    -   因此，我们将乘积 `(A[i] - '0') * (B[j] - '0')` 累加到 `result[i+j]` 中。

    执行完这个双重循环后，`result` 数组中存储了所有位交叉相乘后的和，但每个位置上的数字可能大于9，需要处理进位。

2.  **处理进位**:
    -   我们从低位到高位（从 `result[0]` 开始）遍历 `result` 数组。
    -   对于每一位 `result[i]`：
        -   如果 `result[i] >= 10`，说明需要进位。
        -   进位的值 `carry = result[i] / 10`。
        -   我们将这个进位加到更高一位上：`result[i+1] += carry`。
        -   当前位只保留个位数：`result[i] %= 10`。
    -   这个过程一直持续到 `result` 数组的最高位。

#### 3. 格式化输出
1.  **去除前导零**:
    -   经过进位处理后，`result` 数组的末尾（即乘积的高位）可能包含一些由初始化或进位产生的多余的0。我们需要从后向前找到第一个非零位，作为输出的起始。
2.  **反向输出**:
    -   从找到的最高非零位开始，向前遍历 `result` 数组，将每一位数字输出。
3.  **处理零的特殊情况**:
    -   如果输入中有一个数为0，或者两个都为0，最终的乘积就是0。我们的算法在去除前导零后可能会导致什么都不输出。因此需要一个特殊判断：如果结果的最高位索引小于0（即所有位都是0），则应输出一个 "0"。

这种方法将复杂的乘法运算分解为简单的整数乘法和加法，是解决此类问题的标准方案。
