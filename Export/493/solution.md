## 问题493 题解

### 题目分析

这个问题要求我们进行多次查询，每次查询一个区间内不同数字的个数。这是一个经典的区间查询问题，由于查询次数和数据规模都比较大，简单的暴力方法会超时。我们需要更高效的数据结构来处理。

### 解题思路：离线查询 + 树状数组

这个问题的一个经典解法是离线处理查询，并结合树状数组（或线段树）。

1.  **离线处理**：
    -   我们将所有查询存储起来，而不是在线地（一个一个地）处理它们。
    -   然后，我们按照查询的右端点 `R` 从小到大对所有查询进行排序。

2.  **从左到右扫描**：
    -   我们从左到右遍历原数组 `A`，用一个指针 `i` 从1到n。
    -   我们维护一个 `last_pos` 数组，`last_pos[x]` 记录数字 `x` 最后一次出现的位置。
    -   我们使用一个树状数组 `BIT`。`BIT` 的作用是，当我们查询 `BIT.query(k)` 时，它能告诉我们 `A[1...k]` 中有多少个不同的数字。

3.  **算法流程**：
    -   遍历数组 `A`，当指针到达 `i` 时：
        -   我们考虑数字 `A[i]`。如果它之前出现过（假设在 `p = last_pos[A[i]]`），那么为了避免重复计数，我们需要将它在 `p` 位置的贡献从树状数组中移除。我们执行 `BIT.add(p, -1)`。
        -   然后，我们在当前位置 `i` 为 `A[i]` 添加新的贡献，执行 `BIT.add(i, 1)`。
        -   更新 `last_pos[A[i]] = i`。
    -   在处理完位置 `i` 后，我们检查所有右端点 `R` 恰好为 `i` 的查询。
    -   对于一个查询 `(L, i)`，其答案就是 `A[L...i]` 中不同数字的个数。这可以通过 `BIT.query(i) - BIT.query(L-1)` 来得到。因为我们这样构建的 `BIT`，`query(k)` 得到的是 `A[1...k]` 中最后一次出现的数字的个数。
    -   我们将计算出的答案存储起来。

4.  **输出结果**：当遍历完整个数组后，所有查询的答案都已经计算出来。我们再按照原始的查询顺序输出答案即可。

这个算法的总时间复杂度是 $O(n \log n + Q \log n)$，其中排序查询需要 $O(Q \log Q)$，遍历数组和树状数组操作需要 $O(n \log n)$。
