## 问题504 题解

### 题目分析

这个问题要求我们在一个有序的（非降序）序列中，对每个给定的查询值 `x`，找到序列中最接近它的数字。如果存在两个数字与 `x` 的距离相等，则选择较小的那个。

### 解题思路

由于序列是有序的，我们可以高效地使用二分查找来解决这个问题。

1.  **定位**：
    -   对于一个查询值 `x`，我们可以用二分查找找到它在序列中的位置，或者它应该被插入的位置。
    -   一个非常方便的工具是C++标准库中的 `std::lower_bound`。`lower_bound(..., x)` 会返回一个指向序列中第一个**不小于**（即大于或等于）`x` 的元素的迭代器，我们称之为 `it`。

2.  **确定候选者**：
    -   `*it`（迭代器 `it` 指向的值）是 `x` 的一个最接近的候选者。
    -   `it` 前面的那个元素 `*(it-1)`（如果存在）是另一个最接近的候选者。
    -   最接近 `x` 的数，必然是这两个候选者之一。

3.  **比较与选择**：
    -   我们需要处理几种边界情况：
        -   **如果 `it` 是序列的开头 (`nums.begin()`)**：这意味着 `x` 比序列中所有的数都小或等于第一个数。唯一的候选者就是 `*it`。
        -   **如果 `it` 是序列的末尾 (`nums.end()`)**：这意味着 `x` 比序列中所有的数都大。唯一的候选者就是序列的最后一个数，即 `*(it-1)`。
        -   **如果 `it` 在序列中间**：我们需要比较 `x` 到两个候选者 `*(it-1)` 和 `*it` 的距离。
            -   计算 `dist1 = x - *(it-1)`
            -   计算 `dist2 = *it - x`
            -   如果 `dist1 <= dist2`，说明 `*(it-1)` 更近或者距离相等。根据题意“若有多个数字同样接近，输出最小的那个”，我们应该选择 `*(it-1)`。
            -   否则，选择 `*it`。

**算法复杂度**：
-   对于 `m` 次查询，每次查询都执行一次二分查找。
-   二分查找的时间复杂度是 $O(\log n)$。
-   总的时间复杂度是 $O(m \log n)$。
