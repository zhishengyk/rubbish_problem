## 问题469 题解

### 题目分析

这是一个典型的**分数背包问题**。我们有 $N$ 种物品（鱼），每种物品有其重量（库存量 $A_i$）和价值（总售价 $B_i$）。我们需要在一个有限的容量（市场最大需求量 $D$）内，通过选择装入哪些物品（以及装入多少），来使得总价值最大。

问题的关键在于题目说明：“销售时允许取出一部分库存”。这表明物品是可以被分割的，这是分数背包问题区别于0-1背包问题的核心特征。

### 解题思路

对于分数背包问题，最优解总是可以通过一个简单的**贪心策略**获得：**优先选择性价比最高的物品**。在本题中，“性价比”就是鱼的**单价**。

因此，我们的策略是：计算出每种鱼的单价，然后按照单价从高到低的顺序，尽可能多地出售。

#### 算法步骤

1.  **数据结构**:
    -   为了方便处理，我们可以定义一个结构体或类来存储每种鱼的三个属性：库存量 `stock`，总售价 `total_price`，以及单价 `unit_price`。
    -   创建一个该结构体的数组或 `std::vector`，大小为 $N$。

2.  **数据读取与单价计算**:
    -   读取鱼的种类数 $N$ 和市场总需求 $D$。
    -   读取 $N$ 种鱼的库存量和总售价。
    -   在读取数据的同时或之后，遍历每种鱼，计算其单价：
        `unit_price = (double)total_price / stock;`
        (注意：必须使用浮点数进行除法，以避免整数除法导致的精度丢失。)

3.  **按单价排序**:
    -   这是贪心策略的核心。我们需要将存储所有鱼信息的数组按照 `unit_price` 进行**降序排序**。这样，排在最前面的就是我们应该优先出售的鱼。

4.  **贪心销售**:
    -   初始化总收益 `max_revenue = 0.0` 和剩余需求 `remaining_demand = D`。
    -   遍历**排序后**的鱼数组（从单价最高的开始）：
        -   对于当前遍历到的鱼 `current_fish`：
            -   **如果 `remaining_demand == 0`**: 市场需求已满足，可以直接跳出循环。
            -   **情况 A: 当前鱼的库存可以完全满足剩余需求**
                -   即 `current_fish.stock >= remaining_demand`。
                -   我们只需要卖出 `remaining_demand` 数量的这种鱼。
                -   增加的收益为 `remaining_demand * current_fish.unit_price`。
                -   将这部分收益累加到 `max_revenue`。
                -   此时需求已完全满足，`remaining_demand` 变为0，任务完成。
            -   **情况 B: 当前鱼的库存不足以满足剩余需求**
                -   即 `current_fish.stock < remaining_demand`。
                -   我们将这种鱼的全部库存都卖掉。
                -   增加的收益就是它的总售价 `current_fish.total_price`。
                -   将这部分收益累加到 `max_revenue`。
                -   更新剩余需求：`remaining_demand -= current_fish.stock`。

5.  **输出结果**:
    -   遍历结束后，`max_revenue` 中存储的就是最大总收益。
    -   根据题目要求，使用格式化输出，将结果精确到小数点后两位。
