## 问题524 题解

### 题目分析

本题要求我们在一个给定的数列中，找出所有满足 $A - B = C$ 的数对 $(A, B)$ 的数量。其中 $A$ 和 $B$ 都是数列中的元素。

一个朴素的解法是使用两层循环来枚举所有的数对，然后判断它们的差是否为 $C$。这种方法的时间复杂度为 $O(N^2)$，对于 $N$ 达到 $2 \times 10^5$ 的数据规模，会严重超时。因此，我们需要一种更高效的算法。

### 解题思路

我们可以将条件 $A - B = C$ 变形为 $A = B + C$。这个形式启发我们：对于数列中的每一个数 $B$，我们只需要快速地查找数列中是否存在以及存在多少个等于 $B+C$ 的数 $A$。

为了能够进行快速查找，我们可以先对数列进行**排序**。排序后，我们就可以利用**二分查找**来高效地完成任务。

#### 算法步骤

1.  **数据读取与排序**:
    -   读取整数 $N$ 和 $C$。
    -   读取 $N$ 个整数，存入一个数组或向量中。
    -   对这个数组进行**升序排序**。排序是后续高效查找的基础，时间复杂度为 $O(N \log N)$。

2.  **遍历与二分查找**:
    -   初始化一个计数器 `count = 0`。
    -   我们遍历排序后的数组。对于数组中的每一个元素 `nums[i]`（我们视其为数对中的 $B$）：
        -   计算出我们期望的目标值 `target = nums[i] + C`（即数对中的 $A$）。
        -   现在，我们需要在数组中查找 `target` 出现了多少次。由于数组已经有序，我们可以使用二分查找。
        -   **处理重复元素**: 数列中可能包含重复的数字。如果我们找到了一个 `target`，与 `nums[i]` 匹配的可能不止一个。为了正确计数，我们需要找到 `target` 在排序数组中出现的**所有**次数。
        -   C++ STL 提供了两个非常有用的函数来处理这个问题：
            -   `std::lower_bound(begin, end, value)`: 返回一个迭代器，指向有序范围 `[begin, end)` 中第一个**不小于** `value` 的元素。
            -   `std::upper_bound(begin, end, value)`: 返回一个迭代器，指向有序范围 `[begin, end)` 中第一个**大于** `value` 的元素。
        -   因此，`upper_bound` 返回的迭代器与 `lower_bound` 返回的迭代器之间的距离（即元素的个数），就精确地等于 `target` 在该范围内的出现次数。
    -   **计算次数并累加**:
        -   对于每个 `nums[i]`，我们计算 `target` 的出现次数：
          `occurrences = std::distance(std::lower_bound(nums.begin(), nums.end(), target), std::upper_bound(nums.begin(), nums.end(), target));`
        -   将 `occurrences` 累加到 `count` 中。

3.  **输出结果**:
    -   遍历完成后，`count` 就是满足条件的数对总数。

**注意**:
-   在二分查找时，为了避免重复计算同一个数对（例如，如果 `C=0`，`A[i]` 会和自己匹配），我们应该在 `nums[i]` 之后的位置开始查找 `target`。然而，一个更简单的处理方式是，对于每一个 `nums[i]`，我们在整个数组中查找 `target` 的数量，这样逻辑更统一。因为题目说“不同位置的编号即使相同，也算作不同的数对”，所以这种全局查找是符合题意的。

该算法的总时间复杂度主要由排序（$O(N \log N)$）和 $N$ 次二分查找（$N \times O(\log N)$）构成，因此总体为 $O(N \log N)$，足以通过本题。
