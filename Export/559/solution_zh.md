## 最多出现子串问题解法

本题要求我们在一个字符串 `S` 中，找到一个满足特定条件的子串。筛选条件有三个，优先级从高到低为：
1.  长度不小于 `L`。
2.  在所有满足条件1的子串中，出现次数最多。
3.  如果出现次数相同，选择最长的。
4.  如果长度仍然相同，选择在 `S` 中第一次出现位置最靠前的。

这是一个涉及子串频率和属性的复杂问题，使用暴力枚举所有子串（$O(N^2)$个）再逐一统计频率（$O(N)$）的方法是不可行的。解决此类问题的标准高级数据结构是**后缀自动机 (Suffix Automaton, SAM)**。

### 后缀自动机核心思想

后缀自动机是一个强大的工具，它能以线性时间 ($O(|S|)$) 压缩一个字符串的所有子串信息。对于本题，我们主要利用它的以下几个性质：

*   **状态与子串**: SAM 中的每个状态代表了一个或多个子串。同一个状态代表的所有子串，它们在原字符串 `S` 中的**结束位置集合 (`endpos` set)** 是完全相同的。这个集合的大小，就等于这些子串的出现频率。
*   **`len` 属性**: 每个状态 `st` 有一个 `len` 值，表示该状态所代表的最长子串的长度。
*   **后缀链接 `link`**: `link` 指针构成了一棵树（后缀链接树）。一个状态 `st` 的 `endpos` 集合是其在后缀链接树上所有子节点的 `endpos` 集合的并集。这为我们计算频率提供了便利。

### 算法流程

1.  **构建后缀自动机**:
    *   遍历输入字符串 `S`，一个字符一个字符地扩展，构建出其对应的 SAM。构建过程是线性的。
    *   在构建时，我们需要为每个状态 `st` 维护几个关键信息：
        *   `len[st]`: 状态最长子串的长度。
        *   `link[st]`: 后缀链接。
        *   `next[st]`: 转移函数。
        *   `freq[st]`: 出现次数。对于一个新字符创建的状态，其 `freq` 初始为1，克隆出的状态初始为0。
        *   `pos[st]`: 该状态代表的子串第一次出现时的结束位置。这在构建时自然获得。

2.  **计算所有状态的频率**:
    *   一个状态的真实频率，是它自己的 `freq` 加上它在后缀链接树中所有子孙状态的 `freq` 之和。
    *   我们可以通过一次拓扑排序（或按 `len` 从大到小排序）来处理所有状态。按 `len` 降序遍历状态 `u`，将其频率累加到其父节点（`link[u]`）上：`freq[link[u]] += freq[u]`。这样一次遍历后，`freq[st]` 就存储了正确的出现次数。

3.  **寻找最优解**:
    *   根据题目的三级筛选标准，我们分步进行：
        *   **第一步：找最高频率 `max_freq`**: 遍历所有状态 `st`，如果 `len[st] >= L`，用 `freq[st]` 更新 `max_freq`。
        *   **第二步：找最长长度 `max_len`**: 在所有满足 `freq[st] == max_freq` 并且 `len[st] >= L` 的状态中，找到最大的 `len[st]` 作为 `max_len`。
        *   **第三步：找最早出现位置 `best_start_pos`**: 遍历所有状态 `st`，如果 `freq[st] == max_freq` 且 `len[st] >= max_len`，那么这个状态就包含了一个长度为 `max_len` 的候选子串。该子串的起始位置是 `pos[st] - max_len + 1`。我们找到所有这些候选起始位置中最小的一个。
    *   注意：一个 `len` 更大的状态，它所包含的子串集合中也必然有长度为 `max_len` 的子串。所以第三步的条件是 `len[st] >= max_len`。

4.  **输出结果**:
    *   根据计算出的 `best_start_pos` 和 `max_len`，从原字符串 `S` 中截取子串并输出。

### 代码实现
由于 SAM 的实现较为模板化，这里只展示核心逻辑，完整代码请参考 `std.cpp`。
```cpp
// ... SAM 结构体和构建函数 ...

void solve() {
    // 1. 构建 SAM
    sam_init();
    for (char c : s) sam_extend(c);

    // 2. 计算频率
    //    按 len 降序遍历，累加频率到 link 指针
    ...

    // 3. 寻找最优解
    long long max_freq = 0;
    // 步骤一：找最高频率
    for (state st : all_states) {
        if (st.len >= L) {
            max_freq = max(max_freq, st.freq);
        }
    }

    int max_len = 0;
    // 步骤二：在最高频率下找最长长度
    for (state st : all_states) {
        if (st.freq == max_freq && st.len >= L) {
            max_len = max(max_len, st.len);
        }
    }

    int best_start_pos = s.length();
    // 步骤三：在最高频率和最长长度下找最早出现位置
    for (state st : all_states) {
        if (st.freq == max_freq && st.len >= max_len) {
            best_start_pos = min(best_start_pos, st.pos - max_len + 1);
        }
    }
    
    // 4. 输出
    cout << s.substr(best_start_pos, max_len) << endl;
}
```

### 算法分析
*   **时间复杂度**: $O(|S|)$。构建SAM、计算频率、寻找最优解都是线性时间。
*   **空间复杂度**: $O(|S|)$，用于存储SAM的状态。
