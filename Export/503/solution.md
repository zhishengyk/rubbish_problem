## 问题503 题解

### 题目分析

这个问题要求我们在一个整数序列中，找出所有满足 `A - B = C` 的数对 `(A, B)` 的个数。这里的 `A` 和 `B` 都是序列中的数。这个等式可以变形为 `A = B + C`。

### 解题思路

解决这个问题的关键在于如何高效地为每个数 `B` 找到对应的 `A`。

#### 方法一：排序 + 二分查找

这是解决这类问题的经典方法。

1.  **排序**：
    -   首先，对输入的整数序列进行升序排序。排序是使用二分查找的前提。

2.  **遍历与查找**：
    -   我们遍历排序后的序列。对于序列中的每一个数 `nums[i]`，我们把它看作是数对中的 `B`。
    -   那么，我们需要寻找的 `A` 的值就是 `target = nums[i] + C`。
    -   由于序列是有序的，我们可以使用二分查找来高效地寻找 `target`。

3.  **处理重复数字**：
    -   序列中可能存在重复的数字。如果我们找到一个 `target`，可能序列中有多个 `target`。我们需要把它们都统计进去。
    -   一个高效的方法是使用 `std::lower_bound` 和 `std::upper_bound`：
        -   `lower_bound(..., target)` 找到第一个**不小于** `target` 的位置。
        -   `upper_bound(..., target)` 找到第一个**大于** `target` 的位置。
        -   这两个位置之间的元素个数，就是序列中 `target` 的准确数量。
    -   我们将每次找到的数量累加到总数中。

**算法复杂度**：
-   排序的时间复杂度是 $O(N \log N)$。
-   遍历序列中的每个数，并为每个数执行一次二分查找，这部分的时间复杂度也是 $O(N \log N)$。
-   总的时间复杂度为 $O(N \log N)$。

#### 方法二：排序 + 双指针

我们也可以使用双指针来解决。
1.  **排序**：同上。
2.  **双指针**：
    -   使用两个指针 `i` 和 `j`，都从数组开头开始。
    -   `diff = nums[j] - nums[i]`。
    -   如果 `diff == C`，说明找到了一个或多个解。我们需要统计 `nums[j]` 的数量，并移动 `i`。
    -   如果 `diff < C`，说明差值不够，需要增大 `nums[j]`，即 `j++`。
    -   如果 `diff > C`，说明差值太大了，需要增大 `nums[i]`，即 `i++`。
这种方法也可以在 $O(N \log N)$ (瓶颈在排序) 或 $O(N)$ (如果用哈希表) 的时间内解决问题。
