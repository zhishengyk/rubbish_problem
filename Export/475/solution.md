## 问题475 题解

### 题目分析

这是一个经典的**排队打水问题**，属于**任务调度**的范畴。我们的目标是安排 $n$ 个人的打水顺序，以最小化所有人的**总花费时间**。

“总花费时间”通常被定义为所有人“等待时间”与“打水时间”之和的总和。
$ \text{Total Time} = \sum_{i=1}^{n} (\text{waiting\_time}_i + \text{打水时间}_i) $

由于所有人的总打水时间 $\sum T_i$ 是一个固定值，所以要最小化总花费时间，就等价于**最小化所有人的总等待时间**。

### 贪心策略

这个问题的最优解可以通过一个直观的贪心策略得到：**应该总是让打水时间短的人先打水**。

-   **单龙头证明**: 假设只有1个水龙头，有两个人A和B，打水时间分别为 $T_A$ 和 $T_B$，且 $T_A < T_B$。
    -   若A先B后：总时间 = $(0+T_A) + (T_A+T_B) = 2T_A + T_B$。
    -   若B先A后：总时间 = $(0+T_B) + (T_B+T_A) = T_A + 2T_B$。
    -   因为 $T_A < T_B$，所以 $2T_A + T_B < T_A + 2T_B$。可见，让时间短的A先打水，总花费更少。这个结论可以推广到 $n$ 个人。

-   **多龙头推广**: 当有 $r$ 个水龙头时，这个基本原则依然适用。为了尽可能减少后面人的等待，我们应该优先处理掉那些耗时短的任务。因此，我们首先需要将所有人**按打水时间升序排序**。然后，将这些人依次分配给当前最早能空闲的水龙头。

### 算法步骤

1.  **数据读取与排序**:
    -   读取人数 $n$，水龙头数 $r$，以及 $n$ 个人的打水时间 $T_i$。
    -   将所有打水时间 $T_i$ 存入一个数组或向量中，并对其进行**升序排序**。

2.  **模拟调度过程**:
    -   我们需要一个数据结构来模拟 $r$ 个水龙头，并追踪每个水龙头何时能变为空闲。一个大小为 $r$ 的数组 `tap_finish_times` 是一个很好的选择，其中 `tap_finish_times[j]` 表示第 $j$ 个水龙头完成当前所有已分配任务的时刻。
    -   初始化 `tap_finish_times` 数组的所有元素为 0。
    -   初始化一个变量 `total_waiting_and_serving_time = 0` 来累计总花费时间。

3.  **贪心分配**:
    -   遍历**排序后**的打水时间数组（从最短的开始）：
        -   对于当前这个人，他的打水时间为 $T_i$。
        -   我们需要找到当前**最早能空闲**的水龙头。这等价于在 `tap_finish_times` 数组中找到**最小值**。
        -   假设 `tap_finish_times[min_idx]` 是最小值。这意味着这个人需要等待 `tap_finish_times[min_idx]` 的时间。
        -   这个人的总花费时间为：`等待时间 + 打水时间` = `tap_finish_times[min_idx] + T_i`。
        -   将这个人的个人花费累加到总花费中：
            `total_waiting_and_serving_time += tap_finish_times[min_idx] + T_i;`
        -   **更新**被占用的水龙头的完成时间。这个人打完水后，这个龙头的完成时刻变为：
            `tap_finish_times[min_idx] = tap_finish_times[min_idx] + T_i;`

4.  **输出结果**:
    -   遍历完所有人后，`total_waiting_and_serving_time` 中存储的就是最小的总花费时间。

-   **优化**: 在第3步中，寻找 `tap_finish_times` 中的最小值，可以使用**最小优先队列（Min-Heap）**来优化。每次从堆顶取出最小值，更新后再插回。这样可以将查找最小值的复杂度从 $O(r)$ 降为 $O(\log r)$，但对于本题的数据范围，直接遍历数组也足够快。
