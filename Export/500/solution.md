## 问题500 题解

### 题目分析

这个问题要求我们在一个升序排列的数列中，找到最后一个小于或等于给定值 `x` 的元素。这是一个非常经典的查找问题，二分查找是解决这个问题的标准且高效的方法。

### 解题思路

由于数列是升序的，我们可以利用这个有序性进行二分查找。

#### 方法一：使用C++标准库 `std::upper_bound`

C++标准库 `<algorithm>` 中提供了一个非常方便的函数 `std::upper_bound`，它的功能是查找有序区间中第一个**大于**给定值的元素。

我们可以巧妙地利用这个函数来解决问题：
1.  **调用函数**：`auto it = std::upper_bound(array.begin(), array.end(), x);`
2.  **定位目标**：`upper_bound` 找到了第一个比 `x` 大的元素。那么，它**前面**的那个元素，必然是最后一个小于或等于 `x` 的元素。
3.  **处理边界情况**：
    -   如果 `it` 等于 `array.begin()`，这意味着数组中所有的元素都比 `x` 大，因此不存在小于或等于 `x` 的元素。此时应输出 -1。
    -   否则，`it` 前面的元素 `*std::prev(it)` 就是我们想要的答案。

这种方法代码简洁，不易出错，且效率很高，时间复杂度为 $O(\log n)$。

#### 方法二：手动实现二分查找

我们也可以自己编写二分查找的逻辑。

1.  **初始化**：设置左右指针 `left = 0`, `right = n-1`，以及一个变量 `ans = -1` 来存储结果。
2.  **循环查找**：当 `left <= right` 时：
    -   计算中间位置 `mid = left + (right - left) / 2`。
    -   如果 `array[mid] <= x`，说明 `mid` 位置的元素是一个可能的答案。我们记录下它 `ans = array[mid]`，然后尝试在右半部分寻找更大的、但仍然小于等于 `x` 的元素，即 `left = mid + 1`。
    -   如果 `array[mid] > x`，说明 `mid` 位置的元素太大了，答案一定在左半部分，即 `right = mid - 1`。
3.  **输出结果**：循环结束后，`ans` 中存储的就是最后一个小于等于 `x` 的元素的值。如果从未找到满足条件的元素，`ans` 保持初值-1。
