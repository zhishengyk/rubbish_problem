## 问题497 题解

### 题目分析

这个问题要求我们模拟对一个01序列进行多次区间翻转操作，并输出最终的序列。初始时，所有硬币都为0（正面朝上）。一次翻转操作相当于将区间内的0变为1，1变为0。

### 解题思路

一个硬币的最终状态只取决于它被翻转的总次数的奇偶性。
-   如果一个硬币被翻转了偶数次，它的状态不变，最终仍为0。
-   如果一个硬币被翻转了奇数次，它的状态改变，最终变为1。

因此，问题的核心就转化为了**计算每个硬币被翻转的总次数**。这是一个区间更新问题，非常适合使用差分数组来解决。

1.  **差分思想**：我们不直接记录每个硬币的翻转次数，而是记录翻转次数的变化量。我们创建一个差分数组 `diff`，大小为 `n+2`。

2.  **区间更新**：对于每一次操作，翻转区间 `[l, r]`，我们可以将其转化为对差分数组的两次单点修改：
    -   `diff[l]++`：这表示从位置 `l` 开始，之后的所有位置的翻转次数都+1。
    -   `diff[r+1]--`：这表示从位置 `r+1` 开始，抵消掉前面的+1操作，使得只有 `[l, r]` 区间内的翻转次数受到了影响。
    -   我们对所有 `m` 次操作都进行这样的处理。这个过程的时间复杂度是 $O(m)$。

3.  **还原并计算最终状态**：
    -   在处理完所有操作后，我们可以通过对差分数组 `diff` 求前缀和来得到每个位置的实际翻转次数。
    -   令 `flip_count[i]` 为第 `i` 个硬币的总翻转次数。则 `flip_count[i] = flip_count[i-1] + diff[i]`。
    -   我们可以在一次遍历中完成这个计算。从 `i=1` 到 `n`，维护一个变量 `current_flips`，`current_flips += diff[i]`。
    -   然后根据 `current_flips` 的奇偶性来确定第 `i` 个硬币的最终状态并输出。
    -   这个过程的时间复杂度是 $O(n)$。

总的算法复杂度为 $O(n+m)$，非常高效。
