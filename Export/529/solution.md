## 问题529 题解

### 题目分析

本题要求我们在一个给定的数字序列中，找出一个**子序列**（不要求连续），使得该子序列满足“完美团队”的条件，并且长度尽可能长。

“完美团队”的条件是：子序列中的最大值 $M$ 和最小值 $m$ 满足 $M \le m \times p$。

### 问题转化：从子序列到连续子数组

直接处理子序列问题通常比较复杂。我们可以通过一个关键的观察来简化问题：**最优解一定对应于原数组排序后的一个连续子数组**。

**证明**:
1.  首先，对原始的年龄序列进行**升序排序**。这不会影响我们能构成的子序列的内容，只会让元素变得有序。
2.  假设我们已经找到了一个最优的“完美”子序列 $S$，它在排序后的数组中可能不是连续的。设这个子序列的最小值为 $m$（对应排序后数组的 `A[i]`），最大值为 $M$（对应 `A[j]`，其中 $i < j$）。
3.  根据完美团队的定义，我们有 $M \le m \times p$。
4.  现在，考虑排序后数组中位于 `A[i]` 和 `A[j]` 之间的所有元素 `A[k]`（其中 $i < k < j$）。由于数组是排序的，我们必然有 $m = A[i] \le A[k] \le A[j] = M$。
5.  这意味着，`A[k]` 也可以被包含在这个团队中而不会违反“完美”条件，因为最小值仍然是 $m$，最大值仍然是 $M$。
6.  因此，我们可以将从 `A[i]` 到 `A[j]` 的**所有**元素都加入到我们的子序列中，形成一个更长（或等长）的“完美”子序列。
7.  这证明了，任何一个非连续的最优子序列，都可以被扩展成一个连续的、同样满足条件且长度不小于前者的子序列。所以，我们只需要在排序后的数组中寻找**最长的、满足条件的连续子数组**即可。

### 解题思路：排序 + 滑动窗口

问题转化后，变为：在排序后的数组 `A` 中，寻找一个最长的连续子数组 `[i...j]`，使得 `A[j] <= A[i] * p`。

这是一个非常适合使用**滑动窗口（或双指针）**技巧来解决的问题。

#### 算法步骤

1.  **排序**:
    -   读取输入数据 $N$, $p$ 以及 $N$ 个年龄。
    -   对这 $N$ 个年龄进行**升序排序**。

2.  **滑动窗口**:
    -   初始化两个指针 `left = 0`, `right = 0`，代表窗口的左右边界。
    -   初始化一个变量 `max_len = 0` 来记录找到的最长长度。

3.  **遍历与窗口移动**:
    -   使用一个 `for` 循环，让 `right` 指针从 `0` 遍历到 `N-1`，不断尝试向右扩大窗口。
    -   在循环的每一步中，我们检查当前窗口 `[left...right]` 是否满足条件 `A[right] <= A[left] * p`。
    -   使用一个 `while` 循环来维护这个条件：
        `while (A[right] > A[left] * p)`
        -   如果条件不满足，说明窗口的左边界 `A[left]` 相对于右边界 `A[right]` 来说太小了。
        -   我们需要**收缩窗口**，将左边界向右移动：`left++`。
    -   当 `while` 循环结束后，我们保证了当前窗口 `[left...right]` 是一个满足条件的、以 `A[right]` 为最大值的最长子数组。
    -   **更新最大长度**:
        -   当前窗口的长度为 `right - left + 1`。
        -   我们用这个长度来更新全局的最长长度：`max_len = max(max_len, right - left + 1);`

4.  **输出结果**:
    -   当 `right` 指针遍历完整个数组后，`max_len` 就是最终的答案。

该算法的总时间复杂度由排序主导，为 $O(N \log N)$，后续的滑动窗口过程为 $O(N)$。
