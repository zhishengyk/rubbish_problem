## 问题495 题解

### 题目分析

这个问题要求我们在给定范围内多次查询区间内的质数个数。由于查询的右端点最大值 `m` 达到了 $10^6$，且查询次数较多，我们需要一个高效的方法来预处理质数信息。

### 解题思路

这个问题可以分解为两个步骤：预处理和查询。

1.  **预处理：筛选质数**
    -   我们可以使用**埃拉托斯特尼筛法（Sieve of Eratosthenes）**来高效地找出从1到 `m` 之间的所有质数。
    -   **算法流程**：
        -   创建一个大小为 `m+1` 的布尔数组 `is_prime`，初始化所有值为 `true`。
        -   从 `p=2` 开始，如果 `is_prime[p]` 为 `true`，则 `p` 是一个质数。
        -   将 `p` 的所有倍数（`2p`, `3p`, `4p`, ...）标记为非质数（`is_prime[...] = false`）。
        -   继续寻找下一个 `is_prime` 值为 `true` 的数，重复上述过程，直到 `p*p > m`。
    -   这个筛选过程的时间复杂度大约是 $O(m \log \log m)$。

2.  **预处理：计算前缀和**
    -   在得到1到 `m` 的质数信息后，为了能够快速响应区间查询，我们可以再计算一个前缀和数组 `prime_count`。
    -   `prime_count[i]` 表示在 `[1, i]` 区间内质数的总个数。
    -   递推关系为：`prime_count[i] = prime_count[i-1] + (is_prime[i] ? 1 : 0)`。
    -   这个过程的时间复杂度是 $O(m)$。

3.  **响应查询**
    -   对于每个查询 `(l, r)`：
        -   首先，检查 `l` 和 `r` 是否在 `[1, m]` 的有效范围内。如果超出范围，则输出 "Crossing the line"。
        -   如果范围有效，那么 `[l, r]` 区间内的质数个数就可以通过前缀和数组在 $O(1)$ 时间内计算出来：`prime_count[r] - prime_count[l-1]`。

通过这种“预处理+查询”的模式，我们可以高效地解决这个问题。
