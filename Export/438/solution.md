## 问题438 题解

### 题目分析

本题要求我们统计所有 `n` 位数中，包含偶数个数字 `3` 的数的总数，并将结果对 `12345` 取模。注意，`n` 位数的最高位不能是 `0`。

### 解题思路

这是一个典型的**数字动态规划（Digit DP）**问题。我们可以通过构建位数 `i` 的解与位数 `i-1` 的解之间的关系来找到答案。

#### 1. 定义状态

我们需要根据两个维度来定义我们的DP状态：
-   当前处理的位数 `i`。
-   到目前为止，数字 `3` 出现的次数是奇数还是偶数。

因此，我们可以定义一个二维 `dp` 数组：
-   `dp[i][0]`：表示 `i` 位数中，含有**偶数**个数字 `3` 的个数。
-   `dp[i][1]`：表示 `i` 位数中，含有**奇数**个数字 `3` 的个数。

我们的最终目标是求解 `dp[n][0]`。

#### 2. 寻找递推关系

我们考虑如何从 `i-1` 位数构造出 `i` 位数。

**对于 `dp[i][0]` (i位数，偶数个3):**
一个 `i` 位数可以通过在一个 `i-1` 位数前面添加一个数字（1-9）来构成。
-   **情况 A**: 在一个**偶数**个3的 `i-1` 位数前面添加一个非3的数字。
    -   `i-1` 位数有 `dp[i-1][0]` 种。
    -   可以添加的非3数字有8个（1, 2, 4, 5, 6, 7, 8, 9）。
    -   贡献: `dp[i-1][0] * 8`
-   **情况 B**: 在一个**奇数**个3的 `i-1` 位数前面添加一个数字3。
    -   `i-1` 位数有 `dp[i-1][1]` 种。
    -   只能添加数字3。
    -   贡献: `dp[i-1][1] * 1`

但是，这种从前往后加数字的方式对于最高位的限制（不能为0）处理起来比较复杂。让我们换一种思路，从后往前加数字（即在 `i-1` 位数的末尾添加数字）。

假设我们已经求出了 `dp[i-1][0]` 和 `dp[i-1][1]`。现在要构造 `i` 位数。
一个 `i` 位数可以看作一个 `i-1` 位数后面追加一位数字（0-9）。

**计算 `dp[i][0]` (i位数，偶数个3):**
1.  取一个有偶数个3的 `i-1` 位数 (`dp[i-1][0]` 种)，在末尾追加一个非3的数字。
    -   有 `dp[i-1][0]` 种基础数。
    -   有9个非3数字（0,1,2,4,5,6,7,8,9）可以追加。
    -   贡献: `dp[i-1][0] * 9`
2.  取一个有奇数个3的 `i-1` 位数 (`dp[i-1][1]` 种)，在末尾追加一个数字3。
    -   有 `dp[i-1][1]` 种基础数。
    -   只能追加数字3。
    -   贡献: `dp[i-1][1] * 1`

**`dp[i][0] = (dp[i-1][0] * 9 + dp[i-1][1]) % 12345`**

**计算 `dp[i][1]` (i位数, 奇数个3):**
1.  取一个有偶数个3的 `i-1` 位数 (`dp[i-1][0]` 种)，在末尾追加一个数字3。
    -   贡献: `dp[i-1][0] * 1`
2.  取一个有奇数个3的 `i-1` 位数 (`dp[i-1][1]` 种)，在末尾追加一个非3的数字。
    -   贡献: `dp[i-1][1] * 9`

**`dp[i][1] = (dp[i-1][0] + dp[i-1][1] * 9) % 12345`**

#### 3. 确定基本情况 (Base Case)

我们需要 `dp[1]` 的值来启动递推。
-   **`dp[1][0]` (1位数，偶数个3):**
    -   数字可以是 1, 2, 4, 5, 6, 7, 8, 9。共8个。
    -   `dp[1][0] = 8`
-   **`dp[1][1]` (1位数，奇数个3):**
    -   数字只能是 3。共1个。
    -   `dp[1][1] = 1`

### 算法实现

1.  创建一个 `(n+1) x 2` 的DP数组。
2.  初始化 `dp[1][0] = 8` 和 `dp[1][1] = 1`。
3.  使用循环从 `i = 2` 到 `n`，根据上述递推公式计算 `dp[i][0]` 和 `dp[i][1]`。
4.  在每步计算中都对 `12345` 取模。
5.  最终答案是 `dp[n][0]`。
