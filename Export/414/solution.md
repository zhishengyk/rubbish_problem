## 问题414 题解

### 题目分析

本题是一个病人看病排序的模拟问题。排序的规则比较复杂，涉及到优先级和多重条件，可以总结为：

1.  **优先级**：老年人（年龄≥60岁）的优先级高于非老年人。
2.  **老年人内部排序**：按年龄从大到小排序；若年龄相同，则按登记的先后顺序（先登记的优先）。
3.  **非老年人内部排序**：只按登记的先后顺序排序。

### 解题思路

处理这种带有优先级的多组排序问题，一个清晰高效的方法是**分组处理**。

1.  **定义数据结构**：
    -   创建一个`Patient`结构体来完整地存储每个病人的信息。关键是要包含三个成员：`id`（字符串），`age`（整数），以及一个`registration_order`（整数）来记录其原始的输入顺序。这个“登记顺序”是解决排序问题的关键。

2.  **数据分组**：
    -   创建两个`std::vector<Patient>`，一个用于存放老年病人 (`senior_patients`)，另一个用于存放非老年病人 (`other_patients`)。
    -   在循环读取输入时，为每个病人赋予一个从0开始递增的`registration_order`。
    -   根据病人的年龄是否大于等于60，将其存入对应的向量中。

3.  **分别排序**：
    -   **老年人组**：这一组需要自定义排序。我们需要编写一个比较函数`compareSeniorPatients`，其逻辑如下：
        -   首先比较年龄`age`，年龄大的排在前面 (`a.age > b.age`)。
        -   如果年龄相同，则比较`registration_order`，登记顺序靠前的排在前面 (`a.registration_order < b.registration_order`)。
        -   使用`std::sort`配合这个自定义比较函数对`senior_patients`向量进行排序。
    -   **非老年人组**：这一组的排序规则是按登记顺序。因为我们本身就是按照登记顺序将他们加入`other_patients`向量的，所以这个向量**天然有序，无需进行任何额外的排序操作**。

4.  **合并输出**：
    -   首先，遍历排序好的`senior_patients`向量，依次输出每个病人的`id`。
    -   然后，遍历`other_patients`向量，依次输出每个病人的`id`。

这个“先分组，再分别处理”的策略将复杂问题分解为几个简单的小问题，使得逻辑非常清晰，易于实现和调试。
