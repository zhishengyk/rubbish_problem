## 问题426 题解

### 题目分析

本题要求计算 $a^b \pmod{1000000007}$ 的值。这是一个非常典型的模幂运算问题。由于底数`a`和指数`b`的范围都很大（可达 $10^9$），直接使用循环进行`b`次乘法会严重超时，并且计算的中间结果会远远超出`long long`的表示范围。

因此，必须使用一种更高效的算法来处理大指数的幂运算，即**快速幂**算法。

### 解题思路：快速幂（Exponentiation by Squaring）

快速幂算法的核心思想是利用指数`b`的二进制表示来将时间复杂度从 $O(b)$ 优化到 $O(\log b)$。

#### 算法原理

任何指数`b`都可以写成二进制的形式，例如 $b=13$，其二进制是 $1101_2$。
$13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0$

因此，$a^{13}$ 可以分解为：
$a^{13} = a^{8+4+1} = a^8 \times a^4 \times a^1$

我们发现，计算 $a^b$ 所需的乘法项，只与`b`的二进制表示中为`1`的位有关。而像 $a^1, a^2, a^4, a^8, ...$ 这些项，可以通过对底数`a`进行连续平方轻松得到：$a^2 = a^1 \times a^1$, $a^4 = a^2 \times a^2$, $a^8 = a^4 \times a^4$, ...

#### 迭代实现

我们可以通过一个循环来模拟这个过程，这比递归实现更高效：

1.  **初始化**:
    -   `result = 1`：用于存储最终结果。
    -   `base = a`：代表当前 $a^{2^i}$ 的值。
    -   `mod = 1000000007`：题目要求的模数。
    -   注意：在所有计算中，乘法操作后都要立即取模，以防止中间结果溢出。

2.  **循环**: 当指数`b`还大于0时，不断循环。

3.  **核心逻辑**:
    -   **检查`b`的最低位**：使用 `if (b % 2 == 1)` 或 `if (b & 1)` 来判断`b`的二进制最低位是否为1。
        -   如果为1，说明最终结果需要乘以当前的`base`项。执行 `result = (result * base) % mod;`
    -   **更新`base`**：无论`b`的最低位是什么，`base`都需要为下一轮做准备，即自身平方。执行 `base = (base * base) % mod;`。
    -   **更新`b`**：将`b`整除2（或右移一位 `b >>= 1`），相当于考察`b`的下一位。

4.  **返回结果**：当`b`变为0时，循环结束，`result`中存储的就是 $a^b \pmod{mod}$ 的最终答案。

这个算法优雅地将指数的线性问题转化为了对数问题，是处理大数模幂的标准解决方案。
