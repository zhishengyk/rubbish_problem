## 问题453 题解

### 题目分析

本题要求我们对两个非常大的正整数 `A` 和 `B` 进行加法和减法运算。由于输入的数字长度可以达到 $10^4$ 位，远远超过了任何标准整型（如 `long long`）的表示范围，因此必须使用 **高精度算法** 来解决。

### 解题思路

我们需要将大数以字符串或数组的形式存储，并模拟小学的竖式加法和减法过程。

#### 1. 数据存储
-   使用 `std::string` 来读取和存储大整数。
-   为了方便计算（从个位开始处理），一个常用技巧是**将读入的数字字符串进行反转**。这样，数字的个位、十位、百位...就分别对应字符串的索引 `0, 1, 2, ...`，使得对位相加/减变得简单。

---

### 2. 高精度加法 (`A + B`)

该过程模拟竖式加法：
1.  **逐位相加**：从最低位（索引0）开始，将 `A` 和 `B` 对应位上的数字相加，并加上来自前一位的**进位 (`carry`)**。
2.  **计算当前位和进位**:
    -   `current_digit_sum = (A[i] - '0') + (B[i] - '0') + carry`
    -   结果的当前位是 `current_digit_sum % 10`。
    -   新的进位 `carry` 是 `current_digit_sum / 10`。
3.  **处理不等长**: 当一个数的所有位都处理完后，继续用另一个数剩下的高位与进位相加。
4.  **最终进位**: 循环结束后，如果 `carry` 仍为1，需要在结果的最高位补上一个 '1'。
5.  **反转结果**: 将计算得到的结果字符串再次反转，恢复为正常的数字顺序。

---

### 3. 高精度减法 (`A - B`)

该过程模拟竖式减法，但需要先处理符号：
1.  **比较大小**: 首先需要判断 `A` 和 `B` 的大小，以确定谁是减数，谁是被减数，以及结果的符号。
    -   如果 `A` 的位数多于 `B`，则 `A > B`。
    -   如果 `B` 的位数多于 `A`，则 `B > A`。
    -   如果位数相同，则从高位（反转前的字符串首位）开始逐位比较，直到找到第一个不同的数字。
2.  **保证大数减小数**:
    -   如果 `A >= B`，则计算 `A - B`，结果为正。
    -   如果 `A < B`，则计算 `B - A`，并在结果前添加负号 `-`。
3.  **逐位借位相减**:
    -   从最低位开始，`被减数位 - 减数位 - 借位(borrow)`。
    -   如果结果为负，则向高位借1（`borrow = 1`），当前位的结果加上10。
    -   否则，`borrow = 0`。
4.  **去除前导零**: 减法的结果可能会产生前导零（例如 `100 - 99 = 001`）。在输出前需要将这些多余的零去掉。一个特殊情况是，如果结果本身就是0，则应保留一个 '0'。
5.  **反转结果**: 同样需要将结果字符串反转。

通过将这些逻辑封装成独立的函数，可以使代码结构更清晰。
