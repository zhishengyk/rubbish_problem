# 路灯与黑暗

## 题目背景
一条笔直的大道，长度为 \(L\) 米。坐标以米为单位，均为**整数**。道路两端 —— 坐标 **0** 与 **\(L\)** —— 已永久安装路灯，且无法被移除。其余位置最初没有路灯，随后会按指令动态地增设或拆除路灯。城市照明部门希望实时得知当前最长的一段黑暗路段（即相邻路灯之间的最大间距）的长度。

## 题目描述
给定道路长度 \(L\) 以及 \(m\) 次在线操作，请按顺序处理下列三种指令：

1. `add x`   (0 < x < L)
   在坐标 \(x\) 处安装一盏路灯；若该位置已存在路灯则忽略。
2. `remove x` (0 < x < L)
   拆除坐标 \(x\) 处的路灯；保证该位置目前确实有且仅有一盏可拆除的路灯（绝不会拆除两端坐标 0、\(L\) 的永久路灯）。
3. `query`
   输出当前最长连续黑暗区间（即相邻两盏路灯之间的最大距离）的长度。

你需要对每条 `query` 指令各输出一行答案。

## 输入格式
```
L m
<接下来 m 行，每行一条操作>
```
* 1 ≤ **L** ≤ 10<sup>9</sup>
* 1 ≤ **m** ≤ 2 × 10<sup>5</sup>
* 坐标 **x** 均为整数，且满足 0 &lt; x &lt; L。
* 所有操作需按输入顺序在线处理。

## 输出格式
对每个 `query` 操作，输出一行一个整数，表示当前最黑区间的长度。

## 样例
### 输入
```
10 8
add 3
query
add 6
query
remove 3
query
add 7
query
```
### 输出
```
7
4
6
6
```
### 说明
| 步骤 | 操作      | 路灯坐标集合        | 黑暗区间划分                   | 最长长度 |
|-----|-----------|-------------------|--------------------------------|----------|
| 0   | 初始      | {0, 10}           | [0, 10]                        | 10       |
| 1   | add 3     | {0, 3, 10}        | [0, 3], [3, 10]               | 7        |
| 2   | query     | —                 | —                              | 7        |
| 3   | add 6     | {0, 3, 6, 10}     | [0, 3], [3, 6], [6, 10]       | 4        |
| 4   | query     | —                 | —                              | 4        |
| 5   | remove 3  | {0, 6, 10}        | [0, 6], [6, 10]               | 6        |
| 6   | query     | —                 | —                              | 6        |
| 7   | add 7     | {0, 6, 7, 10}     | [0, 6], [6, 7], [7, 10]       | 6        |
| 8   | query     | —                 | —                              | 6        |

## 数据范围与提示
* 在线处理，单次操作需 \(O(\log m)\) 或均摊 \(O(1)\) 时间。
* 推荐做法：
  * 使用 `std::set<int>` 维护所有路灯坐标的有序集合。
  * 使用 `std::multiset<int>`（或两端堆、平衡树）维护所有黑暗区间长度。插入、删除、查询均为 \(O(\log m)\)。

## 进阶挑战
若你已轻松解决本题，可考虑再支持操作：

* `kth k` —— 输出当前第 \(k\) 长的黑暗区间长度（1 ≤ k ≤ 区间数）。

实现可采用 GNU PBDS 的 `tree_order_statistics`，或在线段树、权值桶等数据结构上拓展查询功能。